<!DOCTYPE html>
<html lang="en">
<head>
  <style>
  </style>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>World Satellite Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />
  <style>
    #map {
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
      /* Darken map background to avoid bright flashes under tiles */
      background: #0b0b0b;
    }
    body {
      margin: 0;
      padding: 0;
    }
    .control-panel {
      position: absolute;
      z-index: 1000;
      right: 400px;
      top: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      
      margin: 0;
    }
    .map-btn-img {
      position: relative;
      display: inline-block;
      width: 32px;
      height: 32px;
    }
    .map-btn-img img {
      width: 32px;
      height: 32px;
      display: block;
    }
    .map-btn-num {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.3em;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 4px #000, 0 0 2px #333;
      pointer-events: none;
    }
    .location-btn.memorize-mode {
      background-color: #e74c3c;
      color: white;
    }
    .location-btn.memorize-mode:hover {
      background-color: #c0392b;
    }
    .location-btn.go-mode {
      background-color: #3498db;
      color: white;
    }
    .location-btn.go-mode:hover {
      background-color: #2980b9;
    }
    .other-buttons {
      display: flex;
      flex-direction: column;
      gap: 0px;
      align-items: flex-start;
      margin-top: 10px;
    }
    .other-buttons button {
      display: flex;
      align-items: center;
      width: 48px;
      height: 48px;
      padding: 0;
      border: none;
      border-radius: 0px;
      background: none;
      cursor: pointer;
    }
    .other-buttons button:hover {
      background-color: #7f8c8d;
    }
    #drawing-panel {
      top: 80px;
      right: 70px;
      width: 32px;
    }
    #mode-panel {
      top: 10px;
      right: 10px;
      width: 92px;
    }
      #map-panel {
        top: 80px;
        right: 10px;
        width: 50px; /* widened panel to fit wider buttons */
        padding: 0; /* ensure content fits exact width */
      }
      /* Make sure location buttons fit exactly inside the 32px panel */
      #map-panel .location-buttons {
        display: block;
        flex-direction: column;
        align-items: center;
        gap: 40px;
        margin: 0;
        padding: 0;
        align-items: center;
        justify-content: center;
        
      }
      #map-panel .location-btn {
        width: 50px;  /* wider click target */
        height: 50px; /* slightly taller for symmetry */
        padding: 0;
        border: none;
        background: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #map-panel .map-btn-img,
      #map-panel .map-btn-img img {
        width: 32px;  /* keep the icon at 32px */
        height: 32px;
        display: block;
      }
    #action-mode-panel {
      position: absolute;
      z-index: 1000;
      right: 200px;
      top: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 0;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-family: Arial, sans-serif;
    }
    .action-mode-switch {
      display: flex;
      flex-direction: column;
      gap: 0px;
      align-items: flex-start;
    }
    .action-mode-switch button {
      width: 90px;
      height: 32px;
      font-size: 1em;
      cursor: pointer;
      border: none;
      background: #eee;
      margin-bottom: 4px;
    }
    .action-mode-switch button.selected {
      background: #3498db;
      color: white;
    }
    .color-palette-buttons {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: center;
    }
    .palette-color-btn {
      width: 32px;
      height: 32px;
      border: none;
      cursor: pointer;
      position: relative;
    }
    .palette-color-btn:hover {
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }
    .palette-color-btn.selected {
      border: 2px solid #333;
    }
    /* Selection highlight for units */
    .leaflet-marker-icon.unit-selected {
      filter: drop-shadow(0 0 6px yellow) brightness(1.15);
    }
    /* Heading tooltip styling */
    .heading-tooltip .leaflet-tooltip-content { padding: 2px 4px; }
  .heading-tip { display: inline-flex; align-items: center; gap: 0; font-family: Arial, sans-serif; font-size: 11px; color: #fff; text-shadow: 0 1px 1px rgba(0,0,0,0.6); }
    .leaflet-tooltip.heading-tooltip { background: rgba(0,0,0,0.65); border: 0; border-radius: 3px; box-shadow: 0 1px 4px rgba(0,0,0,0.3); }
  .leaflet-tooltip.heading-tooltip.leaflet-tooltip-top:before,
  .leaflet-tooltip.heading-tooltip.leaflet-tooltip-bottom:before,
  .leaflet-tooltip.heading-tooltip.leaflet-tooltip-left:before,
  .leaflet-tooltip.heading-tooltip.leaflet-tooltip-right:before { display: none; }
  /* Measure popup styling: no pointer tip and no rounded corners */
  .leaflet-popup.measure-popup .leaflet-popup-tip-container { display: none; }
  .leaflet-popup.measure-popup .leaflet-popup-content-wrapper { border-radius: 0; background: rgba(0,0,0,0.9); color: #fff; }
  .leaflet-popup.measure-popup .leaflet-popup-content { color: #fff; margin: 6px 8px; }
  .leaflet-popup.measure-popup { border-radius: 0; }
    /* Debug overlay */
    #debug-overlay {
      position: fixed;
      left: 10px;
      bottom: 70px; /* keep a bit above toasts */
      width: 480px;
      max-height: 40vh;
      background: rgba(0,0,0,0.85);
      color: #e6e6e6;
      font: 11px/1.3 Consolas, Menlo, Monaco, monospace;
      padding: 6px 6px 4px 6px;
      z-index: 10000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.4);
      border-radius: 3px;
      display: none; /* hidden by default */
      flex-direction: column;
      gap: 4px;
    }
    #debug-overlay .dbg-head { display:flex; align-items:center; justify-content:space-between; }
    #debug-overlay .dbg-title { font-weight:600; color:#fff; }
    #debug-overlay .dbg-controls button, #debug-overlay .dbg-controls label { font-size: 11px; }
    #debug-lines { overflow:auto; white-space: pre-wrap; word-break: break-word; max-height: 30vh; }
  </style>
</head>
<body>
  
  <div class="control-panel" id="drawing-panel">
    <div class="location-buttons">
      <button id="draw-btn" style="padding:0;border:none;background:none;">
        <img id="draw-btn-img" src="image/IconDrawingG.jpg" alt="Freehand Draw" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="clear-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconClearG.jpg" alt="Clear Drawings" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="undo-btn" style="padding:0;border:none;background:none;">
        <img id="undo-btn-img" src="image/IconUndoG.jpg" alt="Undo" style="width:32px;height:32px;vertical-align:middle;opacity:0.5;">
      </button>
      <button id="move-btn" style="padding:0;border:none;background:none;">
        <img id="move-btn-img" src="image/IconMoveG.jpg" alt="Move" style="width:32px;height:32px;vertical-align:middle;">
      </button>
    </div>
  </div>

  <div class="control-panel" id="tools-panel" style="top: 235px; right: 70px; width: 32px;">
    <div class="location-buttons">
      <button id="measure-btn" style="padding:0;border:none;background:none;">
        <img id="measure-btn-img" src="image/IconRulerG.jpg" alt="Measure Distance" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="tank-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconTankG.jpg" alt="Tank Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="uav-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconUAVG.jpg" alt="UAV Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="jetfighter-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconJetFighterG.jpg" alt="JetFighter Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="helicopter-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconHelicopterG.jpg" alt="Helicopter Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="submarine-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconSubmarineG.jpg" alt="Submarine Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="battleship-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconBattleshipG.jpg" alt="Battleship Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="select-mode-btn" title="Select units" style="padding:0;border:none;background:none;width:32px;height:32px;line-height:32px;text-align:center;">
        <img id="select-mode-btn-img" src="image/IconSelectRectangleG.jpg" alt="Select Units" style="width:32px;height:32px;vertical-align:middle;">
      </button>
  
    </div>
  </div>
  <div class="control-panel" id="map-panel">
    <div class="location-buttons" >
      <button class="location-btn" id="location-1"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-1" style="padding:0;border:none;width:32px;height:32px;"><span class="map-btn-num" id="location-num-1">1</span></span></button>
      <button class="location-btn" id="location-2"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-2" style="padding:0;width:32px;height:32px;"><span class="map-btn-num" id="location-num-2">2</span></span></button>
      <button class="location-btn" id="location-3"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-3" style="padding:0;width:32px;height:32px;"><span class="map-btn-num" id="location-num-3">3</span></span></button>
      <button class="location-btn" id="location-4"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-4" style="padding:0;width:32px;height:32px;"><span class="map-btn-num" id="location-num-4">4</span></span></button>
      <button class="location-btn" id="location-5"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-5" style="padding:0;width:32px;height:32px;"><span class="map-btn-num" id="location-num-5">5</span></span></button>
    </div>
  </div>
  <!-- Bottom-left toast container -->
  <div id="toast-container" style="position:fixed;left:10px;bottom:10px;z-index:9999;display:flex;flex-direction:column;gap:6px;"></div>
  <div class="control-panel" id="mode-panel">
    <div class="mode-switch">
      <button id="mode-memorize" style="padding:0;border:none;background:none;outline:none;">
        <img id="mode-memorize-img" src="image/IconSaveL.jpg" alt="Memorize Mode" style="width:40px;height:40px;vertical-align:middle;">
      </button>
      <button id="mode-go" style="padding:0;border:none;background:none;outline:none;">
        <img id="mode-go-img" src="image/IconGotoMapG.jpg" alt="Go Mode" style="width:40px;height:40px;vertical-align:middle;">
      </button>
    </div>
  </div>
  <div class="control-panel" id="color-palette-panel" style="top: 80px; right: 130px; width: 40px; display: none;">
    <div class="color-palette-buttons">
      <button class="palette-color-btn" data-color="#ff0000" title="Red" style="background:#ff0000;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#00ff00" title="Green" style="background:#00ff00;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#0000ff" title="Blue" style="background:#0000ff;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#000000" title="Black" style="background:#000000;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#ffffff" title="White" style="background:#ffffff;width:32px;height:32px;border:1px solid #ccc;margin-bottom:4px;"></button>
    </div>
  </div>
  <!-- action-mode-panel removed as requested -->
  <div id="map"></div>
  <!-- Debug overlay (bottom-left) -->
  <div id="debug-overlay" aria-live="polite" aria-label="Debug log" role="log">
    <div class="dbg-head">
      <div class="dbg-title">Debug</div>
      <div class="dbg-controls">
        <label title="Pause logging" style="cursor:pointer;margin-right:6px;"><input id="debug-pause" type="checkbox"> Pause</label>
        <button id="debug-clear" title="Clear log">Clear</button>
      </div>
    </div>
    <div id="debug-lines"></div>
  </div>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
  <script>
    // Debug utilities
    (function(){
      var paused = false;
      var maxLines = 200;
      var linesEl = null;
      function ts() {
        var d = new Date();
        var h = (''+d.getHours()).padStart(2,'0');
        var m = (''+d.getMinutes()).padStart(2,'0');
        var s = (''+d.getSeconds()).padStart(2,'0');
        var ms = (''+d.getMilliseconds()).padStart(3,'0');
        return h+':'+m+':'+s+'.'+ms;
      }
      window.debug = function(msg){
        try {
          if (!linesEl) linesEl = document.getElementById('debug-lines');
          if (!linesEl) return;
          if (paused) return;
          var line = document.createElement('div');
          line.textContent = ts() + ' ' + msg;
          linesEl.appendChild(line);
          // Trim
          var extra = linesEl.children.length - maxLines;
          if (extra > 0) {
            for (var i=0; i<extra; i++) {
              try { linesEl.removeChild(linesEl.firstChild); } catch(_){}
            }
          }
          // Auto scroll to bottom
          linesEl.scrollTop = linesEl.scrollHeight;
        } catch(_){ /* no-op */ }
      };
      // Wire controls
      window.addEventListener('DOMContentLoaded', function(){
        var pauseEl = document.getElementById('debug-pause');
        var clearEl = document.getElementById('debug-clear');
        if (pauseEl) pauseEl.addEventListener('change', function(){ paused = !!this.checked; });
        if (clearEl) clearEl.addEventListener('click', function(){
          if (!linesEl) linesEl = document.getElementById('debug-lines');
          if (linesEl) linesEl.innerHTML = '';
        });
      });
      // Global error surfacing
      window.addEventListener('error', function(e){ try { window.debug('[error] ' + (e && e.message ? e.message : 'unknown')); } catch(_){} });
      window.addEventListener('unhandledrejection', function(e){ try { window.debug('[promise] ' + (e && e.reason ? (e.reason.message || e.reason) : 'rejected')); } catch(_){} });
    })();

    function showToast(message, timeoutMs = 2000) {
      const c = document.getElementById('toast-container');
      if (!c) return;
      const el = document.createElement('div');
      el.textContent = message;
      el.style.cssText = 'background:rgba(0,0,0,0.85);color:#fff;padding:6px 10px;border-radius:3px;font-family:Arial, sans-serif;font-size:12px;box-shadow:0 2px 6px rgba(0,0,0,0.3);max-width:280px;';
      c.appendChild(el);
      setTimeout(() => { try { c.removeChild(el); } catch(_){} }, timeoutMs);
    }
    
    // Map setup
  var map = L.map('map').setView([0, 0], 2);
  try { debug('[init] Leaflet map created'); } catch(_){ }
  // Attach unified pointer drawing
  try { attachPointerDrawing(); debug('[init] pointer drawing attached'); } catch(_){ }

    // A resilient tile layer that retries failed tiles with backoff and keeps a larger buffer
    (function(){
      const RetryingTileLayer = L.TileLayer.extend({
        createTile: function(coords, done) {
          const tile = document.createElement('img');
          tile.alt = '';
          tile.setAttribute('role', 'presentation');
          // Hint the browser to decode off the main thread
          try { tile.decoding = 'async'; } catch(_){}
          if (this.options.crossOrigin) tile.crossOrigin = '';

          // Attach load/error handlers
          L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));
          // Wrap our own error handler with retry/backoff
          const onErr = (e) => {
            const att = tile.__retryAttempts || 0;
            this._tileOnErrorEx(done, tile, coords, att, e);
          };
          L.DomEvent.on(tile, 'error', onErr);

          tile.src = this.getTileUrl(coords);
          return tile;
        },
        _tileOnErrorEx: function(done, tile, coords, attempt, e){
          const max = this.options.maxRetries || 3;
          if (attempt < max) {
            const delay = Math.min(1600, 200 * Math.pow(2, attempt));
            // Retry same URL (avoid cache-busting so browser can coalesce)
            const url = this.getTileUrl(coords);
            tile.__retryAttempts = attempt + 1;
            setTimeout(() => { try { tile.src = url; } catch(_){} }, delay);
          } else {
            // Fall back to transparent/error tile via the stock handler
            this._tileOnError(done, tile, e);
          }
        }
      });

      const esriUrl = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
      // Keep previous zoom tiles around (larger keepBuffer) and update during interaction
      const baseLayer = new RetryingTileLayer(esriUrl, {
        maxZoom: 19,
        updateWhenIdle: true,            // defer some work until pan/zoom end for smoother feel
        updateWhenZooming: true,         // still load during zoom animations
        keepBuffer: 3,                   // moderate offscreen retention to balance memory and CPU
        crossOrigin: true,               // allow browser caching and future canvas ops
        detectRetina: false,             // avoid double-density tile loads on HiDPI
        errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAAAAACw=', // transparent
        maxRetries: 2,
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
  }).addTo(map);
  try { debug('[tiles] base layer ready'); } catch(_){ }

      // Proactively warm tiles just outside the viewport to reduce white gaps on quick pans
      // Debounced, limited tile warming to reduce overhead
      const warmedRecently = new Map(); // key -> timestamp
      let warmTimer = null;
      function warmTiles(layer, marginTiles) {
        try {
          const zoom = map.getZoom();
          const tileSize = layer.getTileSize ? layer.getTileSize().x : 256;
          const pixelBounds = map.getPixelBounds();
          const minX = Math.floor(pixelBounds.min.x / tileSize) - marginTiles;
          const maxX = Math.floor(pixelBounds.max.x / tileSize) + marginTiles;
          const minY = Math.floor(pixelBounds.min.y / tileSize) - marginTiles;
          const maxY = Math.floor(pixelBounds.max.y / tileSize) + marginTiles;
          const max = 1 << zoom; // 2^zoom
          const now = Date.now();
          const maxPrefetch = 32; // cap per cycle
          let count = 0;
          for (let ty = Math.max(0, minY); ty <= Math.min(max - 1, maxY); ty++) {
            for (let tx = minX; tx <= maxX; tx++) {
              if (count >= maxPrefetch) return;
              const xw = ((tx % max) + max) % max; // wrap X
              const key = zoom + '/' + xw + '/' + ty;
              const last = warmedRecently.get(key) || 0;
              if (now - last < 30000) continue; // skip if warmed within 30s
              const url = layer.getTileUrl({x: xw, y: ty, z: zoom});
              const img = new Image();
              try { img.decoding = 'async'; } catch(_){}
              try { img.crossOrigin = ''; } catch(_){}
              img.src = url; // let browser cache it
              warmedRecently.set(key, now);
              count++;
            }
          }
        } catch (err) { /* no-op */ }
      }
      function scheduleWarm() {
        if (warmTimer) { clearTimeout(warmTimer); warmTimer = null; }
        const run = function(){ warmTiles(baseLayer, 1); };
        // Prefer running during idle time to reduce jank
        if (typeof requestIdleCallback === 'function') {
          warmTimer = setTimeout(function(){ requestIdleCallback(run, { timeout: 300 }); }, 120);
        } else {
          warmTimer = setTimeout(run, 150);
        }
      }
  map.on('moveend zoomend', scheduleWarm);
      // Initial warm (debounced)
      scheduleWarm();

      // Replace the previous preloadTiles with a version that uses the baseLayer URL
      window.__baseTileLayer = baseLayer;
    })();

    // Simple Move toggle under Undo (icon-only state)
    let moveActive = false;
    const moveBtn = document.getElementById('move-btn');
    const moveImg = document.getElementById('move-btn-img');
    function deactivateMove() {
      moveActive = false;
      if (moveImg) moveImg.src = 'image/IconMoveG.jpg';
    }

    // Helper: determine if any tool (tools panel or drawing) is active
    function isAnyToolActive() {
      return !!placeMode || !!animDrawActive || !!isSelectMode || !!measuring || !!drawingMode;
    }
    // Helper: Only allow map movement when Move is active; otherwise lock interactions
    function updateMapLockByTools() {
      const shouldUnlock = !!moveActive;
      try { applyMapLock(!shouldUnlock); } catch(_) {}
    }

    // Radio group helpers
    function getActiveRadioTool() {
      if (drawingMode) return 'draw';
      if (moveActive) return 'move';
      if (measuring) return 'measure';
      if (isSelectMode) return 'select';
      if (animDrawActive) return 'anim:' + (animDrawUnitType || '');
      return null;
    }

    function deactivateAllRadioTools() {
      // Stop drawing
      if (drawingMode) {
        try { stopFreehandDraw(); } catch(_) {}
        const drawImg = document.getElementById('draw-btn-img');
        if (drawImg) { drawImg.src = 'image/IconDrawingG.jpg'; drawImg.alt = 'Freehand Draw'; }
        const drawBtn = document.getElementById('draw-btn');
        if (drawBtn) drawBtn.style.backgroundColor = '#95a5a6';
        const palettePanel = document.getElementById('color-palette-panel');
        if (palettePanel) palettePanel.style.display = 'none';
      }
      // Stop measuring
      if (measuring) {
        try { stopMeasuring(); } catch(_) {}
        const mImg = document.getElementById('measure-btn-img');
        if (mImg) mImg.src = 'image/IconRulerG.jpg';
        const mBtn = document.getElementById('measure-btn');
        if (mBtn) mBtn.style.backgroundColor = '#95a5a6';
      }
      // Clear select
      if (isSelectMode) {
        isSelectMode = false;
        const selBtn = document.getElementById('select-mode-btn');
        if (selBtn) selBtn.classList.remove('selected');
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
        try { map.getContainer().style.cursor = ''; } catch(_) {}
      }
      // Clear anim-draw
      if (animDrawActive) {
        try { clearAnimDrawMode(); } catch(_) {}
      } else {
        // Ensure unit button visuals are reset if needed
        try { if (typeof updateUnitButtonsVisual === 'function') updateUnitButtonsVisual(null); } catch(_) {}
      }
      // Clear placement (if any legacy placement used)
      try { clearPlaceMode(); } catch(_) {}
      // Move off
      deactivateMove();
      try { updateMapLockByTools(); } catch(_) {}
    }

    function setRadioTool(tool) {
      const current = getActiveRadioTool();
      if (current === tool) {
        // Toggle off if already active
        deactivateAllRadioTools();
        return;
      }
      // Switch: deactivate others first
      deactivateAllRadioTools();
      switch (tool) {
        case 'draw': {
          startFreehandDraw();
          const img = document.getElementById('draw-btn-img');
          if (img) { img.src = 'image/IconDrawingL.jpg'; img.alt = 'Stop Drawing'; }
          const btn = document.getElementById('draw-btn');
          if (btn) btn.style.backgroundColor = '#e74c3c';
          const palettePanel = document.getElementById('color-palette-panel');
          if (palettePanel) palettePanel.style.display = 'block';
          break;
        }
        case 'move': {
          moveActive = true;
          if (moveImg) moveImg.src = 'image/IconMoveL.jpg';
          break;
        }
        case 'measure': {
          startMeasuring();
          const mImg = document.getElementById('measure-btn-img');
          if (mImg) { mImg.src = 'image/IconRulerL.jpg'; mImg.alt = 'Stop Measuring'; }
          const mBtn = document.getElementById('measure-btn');
          if (mBtn) mBtn.style.backgroundColor = '#e67e22';
          break;
        }
        case 'select': {
          isSelectMode = true;
          const selBtn = document.getElementById('select-mode-btn');
          if (selBtn) selBtn.classList.add('selected');
          const selImg = document.getElementById('select-mode-btn-img');
          if (selImg) selImg.src = 'image/IconSelectRectangleL.jpg';
          try { map.getContainer().style.cursor = 'crosshair'; } catch(_) {}
          break;
        }
        case 'anim:tank':
        case 'anim:uav':
        case 'anim:jetfighter':
        case 'anim:helicopter':
        case 'anim:submarine':
        case 'anim:battleship': {
          const t = tool.split(':')[1];
          setAnimDrawMode(t);
          break;
        }
      }
      try { updateMapLockByTools(); } catch(_) {}
    }
    if (moveBtn && moveImg) {
      moveBtn.addEventListener('click', function() { setRadioTool('move'); });
    }
    // Initial policy: lock map until Move is turned on
    try { updateMapLockByTools(); } catch(_) {}

    // Remove Leaflet attribution control
    try { map.attributionControl.remove(); } catch(_){ }

    // Debug: attach event logs (map-level and DOM-level)
    ;(function(){
      function llToStr(ll){
        if (!ll) return '';
        try { return ll.lat.toFixed(5)+','+ll.lng.toFixed(5); } catch(_) { return ''; }
      }
      var lastMapMoveLog = 0;
  map.on('mousedown', function(e){ try { var d = (typeof describeActiveTool==='function')?describeActiveTool():''; debug('[map] mousedown' + (d?' '+d:'') + ' @ ' + llToStr(e.latlng)); } catch(_){ } });
  map.on('mouseup', function(e){ try { var d = (typeof describeActiveTool==='function')?describeActiveTool():''; debug('[map] mouseup  ' + (d?' '+d:'') + ' @ ' + llToStr(e.latlng)); } catch(_){ } });
  map.on('click', function(e){ try { var d = (typeof describeActiveTool==='function')?describeActiveTool():''; debug('[map] click    ' + (d?' '+d:'') + ' @ ' + llToStr(e.latlng)); } catch(_){ } });
      map.on('dblclick', function(e){ try { debug('[map] dblclick  @ ' + llToStr(e.latlng)); } catch(_){ } });
      function getIconUrlForUnit(t){
        try {
          if (t === 'tank' && typeof tankIcon !== 'undefined' && tankIcon.options) return tankIcon.options.iconUrl;
          if (t === 'uav' && typeof uavIcon !== 'undefined' && uavIcon.options) return uavIcon.options.iconUrl;
          if (t === 'jetfighter' && typeof jetfighterIcon !== 'undefined' && jetfighterIcon.options) return jetfighterIcon.options.iconUrl;
          if (t === 'helicopter' && typeof helicopterIcon !== 'undefined' && helicopterIcon.options) return helicopterIcon.options.iconUrl;
          if (t === 'submarine' && typeof submarineIcon !== 'undefined' && submarineIcon.options) return submarineIcon.options.iconUrl;
          if (t === 'battleship' && typeof battleshipIcon !== 'undefined' && battleshipIcon.options) return battleshipIcon.options.iconUrl;
        } catch(_){}
        return '';
      }
      function describeActiveTool(){
        try {
          // Prefer central radio-state helper when available
          var mode = null;
          try { mode = (typeof getActiveRadioTool === 'function') ? getActiveRadioTool() : null; } catch(_){}
          // Drawing line
          if ((typeof drawingMode !== 'undefined' && drawingMode) || mode === 'draw') {
            var color = (typeof penColor !== 'undefined' && penColor) ? penColor : '#ff0000';
            return 'type=line color=' + color;
          }
          // Measuring
          if ((typeof measuring !== 'undefined' && measuring) || mode === 'measure') {
            return 'type=measure';
          }
          // Select
          if ((typeof isSelectMode !== 'undefined' && isSelectMode) || mode === 'select') {
            return 'type=select';
          }
          // Animate-on-draw unit tool
          if ((typeof animDrawActive !== 'undefined' && animDrawActive) || (mode && mode.indexOf('anim:') === 0)) {
            var unit = (typeof animDrawUnitType !== 'undefined' && animDrawUnitType) ? animDrawUnitType : (mode ? mode.split(':')[1] : '');
            var url = getIconUrlForUnit(unit);
            return 'type=icon tool=' + unit + (url ? ' iconMap=' + url : '');
          }
          // Legacy place mode (if used)
          if (typeof placeMode !== 'undefined' && placeMode) {
            var url2 = getIconUrlForUnit(placeMode);
            return 'type=icon tool=' + placeMode + (url2 ? ' iconMap=' + url2 : '');
          }
          // Move
          if ((typeof moveActive !== 'undefined' && moveActive) || mode === 'move') {
            return 'type=move';
          }
          return 'type=none';
        } catch(_) { return 'type=?'; }
      }
      map.on('touchstart', function(e){
        try {
          var msg = '[map] touchstart';
          var desc = describeActiveTool();
          if (desc) msg += ' ' + desc;
          debug(msg);
        } catch(_){ }
      });
      map.on('touchend', function(e){ try { debug('[map] touchend'); } catch(_){ } });
      map.on('movestart', function(){ try { debug('[map] movestart'); } catch(_){ } });
      map.on('moveend', function(){ try { debug('[map] moveend'); } catch(_){ } });
      map.on('zoomstart', function(){ try { debug('[map] zoomstart'); } catch(_){ } });
      map.on('zoomend', function(){ try { debug('[map] zoomend'); } catch(_){ } });

      // DOM-level events to see raw pointer/touch/mouse
      var c = map.getContainer();
      var lastDomMoveLog = 0;
      function xyToLatLng(ev){
        try {
          var rect = c.getBoundingClientRect();
          var x = (ev.clientX != null ? ev.clientX : (ev.touches && ev.touches[0] ? ev.touches[0].clientX : null));
          var y = (ev.clientY != null ? ev.clientY : (ev.touches && ev.touches[0] ? ev.touches[0].clientY : null));
          if (x == null || y == null) return null;
          return map.containerPointToLatLng([x - rect.left, y - rect.top]);
        } catch(_) { return null; }
      }
      function onDom(type){
        return function(ev){
          try {
            var ll = xyToLatLng(ev);
            var pos = ll ? (' @ ' + ll.lat.toFixed(5)+','+ll.lng.toFixed(5)) : '';
            var t = Date.now();
            if (type === 'pointermove' || type === 'mousemove' || type === 'touchmove') {
              if (t - lastDomMoveLog < 150) return; // throttle
              lastDomMoveLog = t;
            }
            var d = (typeof describeActiveTool==='function')?describeActiveTool():'';
            debug('[dom] ' + type + (d?' '+d:'') + pos);
          } catch(_){}
        };
      }
      ['pointerdown','pointerup','mousedown','mouseup','click','dblclick','contextmenu','wheel','touchstart','touchend'].forEach(function(tp){ try { c.addEventListener(tp, onDom(tp), { passive: false }); } catch(_){} });
      // Optionally enable move logs by uncommenting:
      // ['pointermove','mousemove','touchmove'].forEach(function(tp){ try { c.addEventListener(tp, onDom(tp), { passive: false }); } catch(_){} });
    })();

  // Freehand drawing setup
  var drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);
  // Dedicated layer group for temporary preview lines during drawing
  var tempDrawLayer = L.layerGroup().addTo(map);
  var lastDrawnPath = null; // stores the most recent freehand polyline
    var drawHistory = []; // stack of Leaflet layers added by freehand
    // Path-follow animation state
    let pathMoveJobs = [];
    let pathAnimating = false;
    

    // Country borders overlay (toggle via Ctrl+B)
    let bordersLayer = null;
    let bordersVisible = false;
    let bordersLoading = false;
    function showBorders() {
      if (bordersLayer) {
        try { bordersLayer.addTo(map); } catch(_){}
        bordersVisible = true;
        try { showToast('Borders: ON'); } catch(_){}
        return;
      }
      if (bordersLoading) return;
      bordersLoading = true;
      try { showToast('Loading borders...'); } catch(_){}
      try {
        map.createPane('bordersPane');
        map.getPane('bordersPane').style.zIndex = 430; // above tiles, below markers
      } catch(_){ }
      fetch('https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson')
        .then(r => r.json())
        .then(geo => {
          bordersLayer = L.geoJSON(geo, {
            pane: 'bordersPane',
            interactive: false,
            smoothFactor: 1,
            style: function() {
              return { color: '#ffffff', weight: 1, opacity: 0.7, fillOpacity: 0 };
            }
          }).addTo(map);
          bordersVisible = true;
          bordersLoading = false;
          try { showToast('Borders: ON'); } catch(_){}
        })
        .catch(e => {
          bordersLoading = false;
          try { debug('Borders load failed: ' + (e && (e.message || e))); } catch(_){}
          try { showToast('Borders failed to load'); } catch(_){}
        });
    }
    function hideBorders() {
      if (bordersLayer) { try { map.removeLayer(bordersLayer); } catch(_){} }
      bordersVisible = false;
      try { showToast('Borders: OFF'); } catch(_){}
    }
    function toggleBorders() { if (bordersVisible) hideBorders(); else showBorders(); }
    // Freehand drawing variables
    var isDrawing = false;
    var currentPath = [];
  var drawingMode = false;
  // Color captured at gesture start to keep a stroke consistent even if user switches color mid-gesture
  var currentStrokeColor = null;
  // Track ghost mouse events after touch
  var lastTouchTime = 0;
  // Single temp polyline for freehand preview
  var freehandTempLine = null;
  // Revert to separate mouse/touch handlers (no pointer unification)
  // Pointer-based drawing (unified for mouse & touch)
  var pointerDrawingEnabled = true;
  var activePointerId = null;
  function attachPointerDrawing(){
    try {
      var c = map.getContainer();
      if (!c) return;
      function getLatLngFromPointer(ev){
        try {
          var rect = c.getBoundingClientRect();
          var x = ev.clientX;
          var y = ev.clientY;
          return map.containerPointToLatLng([x - rect.left, y - rect.top]);
        } catch(_) { return null; }
      }
      function onPointerDown(ev){
        if (!pointerDrawingEnabled) return;
        if (!drawingMode) return;
        if (ev.isPrimary === false) return;
        if (ev.pointerType === 'mouse' && ev.button !== 0) return; // left button only
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        var ll = getLatLngFromPointer(ev);
        if (!ll) return;
        activePointerId = ev.pointerId;
        beginFreehandAt(ll);
      }
      function onPointerMove(ev){
        if (!pointerDrawingEnabled) return;
        if (!drawingMode || !isDrawing) return;
        if (activePointerId == null || ev.pointerId !== activePointerId) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        var ll = getLatLngFromPointer(ev);
        if (!ll) return;
        extendFreehandTo(ll);
      }
      function onPointerUp(ev){
        if (!pointerDrawingEnabled) return;
        if (!drawingMode || !isDrawing) return;
        if (activePointerId == null || ev.pointerId !== activePointerId) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        activePointerId = null;
        endFreehand();
      }
      function onPointerCancel(ev){
        if (!pointerDrawingEnabled) return;
        if (!drawingMode || !isDrawing) return;
        if (activePointerId == null || ev.pointerId !== activePointerId) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        activePointerId = null;
        endFreehand();
      }
      c.addEventListener('pointerdown', onPointerDown, { passive: false });
      c.addEventListener('pointermove', onPointerMove, { passive: false });
      c.addEventListener('pointerup', onPointerUp, { passive: false });
      c.addEventListener('pointercancel', onPointerCancel, { passive: false });
    } catch(_){}
  }
  // Unified gesture helpers used by both mouse and touch paths
  function beginFreehandAt(latlng) {
    isDrawing = true;
    currentStrokeColor = penColor || '#ff0000';
    currentPath = [latlng];
  }
  function extendFreehandTo(latlng) {
    currentPath.push(latlng);
    if (currentPath.length > 1) {
      if (!freehandTempLine) {
        var strokeCol = currentStrokeColor || penColor || '#ff0000';
        freehandTempLine = L.polyline(currentPath, { color: strokeCol, weight: 3, opacity: 0.7, temp: true }).addTo(tempDrawLayer);
      } else {
        freehandTempLine.setLatLngs(currentPath);
      }
    }
  }
  function endFreehand() {
    isDrawing = false;
    finalizeFreehandPath();
  }

    function finalizeFreehandPath() {
      if (currentPath.length > 1) {
        // Remove temporary preview line
        if (freehandTempLine) { try { tempDrawLayer.removeLayer(freehandTempLine); } catch(_) {} freehandTempLine = null; }
        // Add final polyline to drawn items
        var strokeCol = currentStrokeColor || penColor || '#ff0000';
        var finalLine = L.polyline(currentPath, { color: strokeCol, weight: 3, opacity: 1 });
        drawnItems.addLayer(finalLine);
        lastDrawnPath = finalLine;
        drawHistory.push(finalLine);
        var undoImgPtr = document.getElementById('undo-btn-img');
        if (undoImgPtr) undoImgPtr.style.opacity = '1';
        if (selectedUnits.length > 0) {
          const pathLatLngs = lastDrawnPath.getLatLngs();
          startPathMoveForMarkers(selectedUnits.slice(), pathLatLngs, 1500);
        }
      }
      currentPath = [];
      currentStrokeColor = null;
    }
    
    // Freehand drawing functions
    function startFreehandDraw() {
      drawingMode = true;
        // Exit select mode to avoid conflicts with marquee handlers
        if (typeof isSelectMode !== 'undefined' && isSelectMode) {
          isSelectMode = false;
          const selImg = document.getElementById('select-mode-btn-img');
          if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
        }
  map.getContainer().style.cursor = 'crosshair';
        map.dragging.disable();
        map.touchZoom && map.touchZoom.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.boxZoom.disable();
        map.keyboard.disable();
        if (map.tap) map.tap.disable();
        // Prevent browser-native touch gestures while drawing
  if (map && map._container) { try { map._container.style.touchAction = 'none'; } catch(_){} }
        // Show color palette when drawing starts
        const palettePanelStart = document.getElementById('color-palette-panel');
        if (palettePanelStart) {
          palettePanelStart.style.display = 'block';
          try { updatePaletteSelection(); } catch(_){}
        }
        try { updateMapLockByTools(); } catch(_) {}
    }
    
    function stopFreehandDraw() {
      drawingMode = false;
      isDrawing = false;
      currentPath = [];
  map.getContainer().style.cursor = '';
      map.dragging.enable();
      map.touchZoom && map.touchZoom.enable();
      map.doubleClickZoom.enable();
      map.scrollWheelZoom.enable();
      map.boxZoom.enable();
      map.keyboard.enable();
      if (map.tap) map.tap.enable();
      // Hide color palette whenever drawing stops (icon turns G)
      const palettePanelStop = document.getElementById('color-palette-panel');
      if (palettePanelStop) palettePanelStop.style.display = 'none';
  // Allow standard touch gestures again
  if (map && map._container) { try { map._container.style.touchAction = ''; } catch(_){} }
    }
    
    function clearAllDrawings() {
      drawnItems.clearLayers();
      try { tempDrawLayer.clearLayers(); } catch(_) {}
      drawHistory = [];
      lastDrawnPath = null;
      var undoImg = document.getElementById('undo-btn-img');
      if (undoImg) undoImg.style.opacity = '0.5';
      if (measureLine) { try { map.removeLayer(measureLine); } catch(_) {} measureLine = null; }
      measureMarkers.forEach(m => { try { map.removeLayer(m); } catch(_) {} });
      measureMarkers = [];
      if (measureTooltip) { try { map.removeLayer(measureTooltip); } catch(_) {} measureTooltip = null; }
      measurePoints = [];
      // Also clear all unit icons on the map
      while (selectedUnits.length) {
        const m = selectedUnits.pop();
        m.isSelected = false;
        if (m._icon) m._icon.classList.remove('unit-selected');
      }
      allMarkers.forEach(m => { try { map.removeLayer(m); } catch(_){} });
      allMarkers.length = 0;
      // Stop any ongoing move/path jobs
      unitMoveJobs = [];
      unitsAnimating = false;
      pathMoveJobs = [];
      pathAnimating = false;
    }

    // Mouse event handlers for freehand drawing
    map.on('mousedown', function(e) {
      if (pointerDrawingEnabled) return; // unified pointer flow is active
      if (!drawingMode) return;
      // Ignore synthetic mouse events shortly after touch
      if (Date.now() - lastTouchTime < 500) return;
      if (e && e.originalEvent) { try { e.originalEvent.preventDefault(); } catch(_){} }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      beginFreehandAt(e.latlng);
    });
    
    map.on('mousemove', function(e) {
      if (pointerDrawingEnabled) return; // unified pointer flow is active
      if (!drawingMode || !isDrawing) return;
      // Ignore synthetic mouse events shortly after touch
      if (Date.now() - lastTouchTime < 500) return;
      if (e && e.originalEvent) { try { e.originalEvent.preventDefault(); } catch(_){} }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      extendFreehandTo(e.latlng);
    });
    
    map.on('mouseup', function(e) {
      if (pointerDrawingEnabled) return; // unified pointer flow is active
      if (!drawingMode || !isDrawing) return;
      // Ignore synthetic mouse events shortly after touch
      if (Date.now() - lastTouchTime < 500) return;
      if (e && e.originalEvent) { try { e.originalEvent.preventDefault(); } catch(_){} }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      endFreehand();
    });
    
    // Touch event handlers for mobile devices
    map.on('touchstart', function(e) {
      if (pointerDrawingEnabled) return; // unified pointer flow is active
      if (!drawingMode) return;
      if (!e.originalEvent) return;
      try { e.originalEvent.preventDefault(); } catch(_){ }
      lastTouchTime = Date.now();
      const touch = e.originalEvent.touches && e.originalEvent.touches[0] ? e.originalEvent.touches[0] : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      beginFreehandAt(latlng);
    });
    
    map.on('touchmove', function(e) {
      if (pointerDrawingEnabled) return; // unified pointer flow is active
      if (!drawingMode || !isDrawing) return;
      if (!e.originalEvent) return;
      try { e.originalEvent.preventDefault(); } catch(_){ }
      lastTouchTime = Date.now();
      const touch = e.originalEvent.touches && e.originalEvent.touches[0] ? e.originalEvent.touches[0] : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      extendFreehandTo(latlng);
    });
    
    map.on('touchend', function(e) {
      if (pointerDrawingEnabled) return; // unified pointer flow is active
      if (!drawingMode || !isDrawing) return;
      if (e && e.originalEvent) { try { e.originalEvent.preventDefault(); } catch(_){} }
      lastTouchTime = Date.now();
      endFreehand();
    });

    // Finalize drawing if the touch/pointer is canceled by the OS (common on Windows)
    (function(){
      const container = map.getContainer();
      function onCancel(ev){
        try { ev.preventDefault(); } catch(_){}
        if (!drawingMode || !isDrawing) return;
        lastTouchTime = Date.now();
        isDrawing = false;
        finalizeFreehandPath();
      }
      try { container.addEventListener('touchcancel', onCancel, { passive: false }); } catch(_){}
      try { container.addEventListener('pointercancel', onCancel, { passive: false }); } catch(_){}
    })();
    

      function computePathMeta(latlngs) {
        const segDist = [];
        let total = 0;
        for (let i = 1; i < latlngs.length; i++) {
          const d = map.distance(latlngs[i-1], latlngs[i]);
          segDist.push(d);
          total += d;
        }
        return { segDist, total };
      }

      function startPathMoveForMarkers(markers, latlngs, speedMetersPerSec) {
        if (!latlngs || latlngs.length < 2 || !markers || markers.length === 0) return;
        // Stop any in-progress move-to animations to avoid conflicts
        unitMoveJobs = [];
        unitsAnimating = false;
        // Stop any existing path animation
        pathMoveJobs = [];
        pathAnimating = false;

        const { segDist, total } = computePathMeta(latlngs);
        if (total <= 0) return;
        const duration = (total / (speedMetersPerSec || 1500)) * 1000;
        const start = performance.now();
        // Create jobs per marker
        markers.forEach(m => {
          pathMoveJobs.push({ marker: m, latlngs, segDist, total, start, duration });
        });
        if (!pathAnimating) requestAnimationFrame(pathAnimLoop);
      }

      function pathAnimLoop() {
        pathAnimating = true;
        const now = performance.now();
        const nextJobs = [];
        for (let i = 0; i < pathMoveJobs.length; i++) {
          const job = pathMoveJobs[i];
          const t = job.duration > 0 ? Math.min(1, (now - job.start) / job.duration) : 1;
          const targetDist = t * job.total;
          const latlngs = job.latlngs;
          const segDist = job.segDist;
          // Find segment
          let acc = 0;
          let si = 0;
          while (si < segDist.length && acc + segDist[si] < targetDist) { acc += segDist[si]; si++; }
          if (si >= segDist.length) {
            job.marker.setLatLng(latlngs[latlngs.length - 1]);
            continue; // job complete
          }
          const segLen = segDist[si];
          const segT = segLen > 0 ? (targetDist - acc) / segLen : 0;
          const a = latlngs[si];
          const b = latlngs[si + 1];
          const lat = a.lat + (b.lat - a.lat) * segT;
          const lng = a.lng + (b.lng - a.lng) * segT;
          job.marker.setLatLng([lat, lng]);
          // Rotate supported unit types
          if (job.marker._icon && ['jetfighter','tank','uav','submarine','battleship','helicopter'].includes(job.marker.unitType)) {
            const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
            const angleDeg = angleRad * 180 / Math.PI;
            job.marker._headingDeg = angleDeg;
            applyMarkerHeading(job.marker);
            updateMarkerTooltip(job.marker);
          }
          if (t < 1) nextJobs.push(job);
        }
        pathMoveJobs = nextJobs;
        if (pathMoveJobs.length > 0) requestAnimationFrame(pathAnimLoop);
        else pathAnimating = false;
      }

    // Button logic
    document.getElementById('draw-btn').onclick = function() { setRadioTool('draw'); };
    
    document.getElementById('clear-btn').onclick = function() {
      clearAllDrawings();
      if (drawingMode) {
        stopFreehandDraw();
        var img = document.getElementById('draw-btn-img');
        img.src = 'image/IconDrawingG.jpg';
        img.alt = 'Freehand Draw';
        document.getElementById('draw-btn').style.backgroundColor = '#95a5a6';
      }
      // Reset undo state
      var undoImg = document.getElementById('undo-btn-img');
      if (undoImg) undoImg.style.opacity = '0.5';
    };

    // Undo last action (drawing path or placed/animated unit)
    document.getElementById('undo-btn').onclick = function() {
      if (!drawHistory || drawHistory.length === 0) return;
      const last = drawHistory.pop();
      if (!last) return;
      // If it's a polyline (drawing)
      if (typeof last.getLatLngs === 'function') {
        try { drawnItems.removeLayer(last); } catch(_) { try { map.removeLayer(last); } catch(_) {} }
        // Update lastDrawnPath to previous polyline if available
        lastDrawnPath = null;
        for (let i = drawHistory.length - 1; i >= 0; i--) {
          const layer = drawHistory[i];
          if (layer && typeof layer.getLatLngs === 'function') { lastDrawnPath = layer; break; }
        }
      } else {
        // Assume it's a marker (placed unit or animated unit)
        try { map.removeLayer(last); } catch(_) {}
        // Remove from allMarkers
        const idx = allMarkers.indexOf(last);
        if (idx !== -1) allMarkers.splice(idx, 1);
        // Remove from selectedUnits if present
        const sidx = selectedUnits.indexOf(last);
        if (sidx !== -1) selectedUnits.splice(sidx, 1);
        // Remove any pending move/animation jobs for this marker
        if (Array.isArray(unitMoveJobs)) {
          unitMoveJobs = unitMoveJobs.filter(j => j && j.marker !== last);
          if (unitMoveJobs.length === 0) { try { unitsAnimating = false; } catch(_){} }
        }
        if (Array.isArray(pathMoveJobs)) {
          pathMoveJobs = pathMoveJobs.filter(j => j && j.marker !== last);
          if (pathMoveJobs.length === 0) { try { pathAnimating = false; } catch(_){} }
        }
      }
      // Dim undo if no more items
      const undoImg = document.getElementById('undo-btn-img');
      if (undoImg) undoImg.style.opacity = drawHistory.length > 0 ? '1' : '0.5';
    };
    
    
    
    // Icon definitions
    var tankIcon = L.icon({
      iconUrl: 'image/IconTankMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var uavIcon = L.icon({
      iconUrl: 'image/IconUAVMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var jetfighterIcon = L.icon({
      iconUrl: 'image/IconJetFighterMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var helicopterIcon = L.icon({
      iconUrl: 'image/IconHelicopterMap.gif',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var submarineIcon = L.icon({
      iconUrl: 'image/IconSubmarineMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var battleshipIcon = L.icon({
      iconUrl: 'image/IconBattleshipMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });

    // Place icon logic
    let placeMode = null;
    let selectedBtn = null;
  // RTS selection + move
  let isSelectMode = false;
  const allMarkers = [];
  const selectedUnits = [];
  let suppressNextMapClick = false;
  let unitMoveJobs = [];
  let unitsAnimating = false;
  // Marquee selection state
  let marqueeActive = false;
  let marqueeMoved = false;
  let marqueeStart = null;
  let marqueeRect = null;
  // Use Pointer Events for marquee selection (unified across mouse/touch/pen)
  let marqueePointerEnabled = true;
  // Select-mode path gesture disabled (reserved for future)
  let selectPathActive = false;
  let selectPathPoints = [];
  let selectPathTempLine = null;
  // Animate-on-draw mode state
  let animDrawActive = false;
  let animDrawUnitType = null; // 'tank' | 'uav' | 'jetfighter' | 'helicopter' | 'submarine' | 'battleship'
  let animDrawPoints = [];
  let animDrawTempLine = null;
  // Map lock when tools are active
  let lockMapWhenToolActive = false;

  function applyMapLock(lock) {
    if (lock) {
      map.dragging.disable();
      map.touchZoom && map.touchZoom.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();
      map.boxZoom.disable();
      map.keyboard.disable();
      if (map.tap) map.tap.disable();
      if (map && map._container) { try { map._container.style.touchAction = 'none'; } catch(_){} }
    } else {
      map.dragging.enable();
      map.touchZoom && map.touchZoom.enable();
      map.doubleClickZoom.enable();
      map.scrollWheelZoom.enable();
      map.boxZoom.enable();
      map.keyboard.enable();
      if (map.tap) map.tap.enable();
      if (map && map._container) { try { map._container.style.touchAction = ''; } catch(_){} }
    }
  }

    // Attach drag handlers so marker rotates following drag direction
    function applyMarkerHeading(m) {
      if (!m || !m._icon || m._headingDeg == null) return;
      const tStr = m._icon.style.transform || '';
      const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
      m._icon.style.transform = `${cleaned} rotate(${m._headingDeg}deg)`;
  m._icon.style.transformOrigin = '50% 50%';
    }

    function updateMarkerTooltip(m) {
      if (!m) return;
      const heading = ((Math.round((m._headingDeg ?? 0)) % 360) + 360) % 360;
  const content = `<span class="heading-tip">${heading}</span>`;
      if (m.getTooltip && m.getTooltip()) { m.setTooltipContent(content); }
    }

    function attachDirectionalDrag(m) {
      m.on('dragstart', function() {
        m._lastDragPoint = map.latLngToLayerPoint(m.getLatLng());
      });
      m.on('drag', function() {
        if (!m._icon) return;
        const prev = m._lastDragPoint;
        const curr = map.latLngToLayerPoint(m.getLatLng());
        if (prev && (curr.x !== prev.x || curr.y !== prev.y)) {
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          const angleRad = Math.atan2(-dy, dx); // invert Y for screen coords
          const angleDeg = angleRad * 180 / Math.PI;
          m._headingDeg = angleDeg;
          applyMarkerHeading(m);
          updateMarkerTooltip(m);
          m._lastDragPoint = curr;
        }
      });
      m.on('dragend', function() {
        if (!m._icon) return;
        const prev = m._lastDragPoint;
        const curr = map.latLngToLayerPoint(m.getLatLng());
        if (prev && (curr.x !== prev.x || curr.y !== prev.y)) {
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          const angleRad = Math.atan2(-dy, dx);
          const angleDeg = angleRad * 180 / Math.PI;
          m._headingDeg = angleDeg;
          applyMarkerHeading(m);
          updateMarkerTooltip(m);
        }
        m._lastDragPoint = null;
      });
    }

    function setPlaceMode(mode) {
      // Deselect previous button
      if (selectedBtn) {
        if (selectedBtn.id === 'tank-btn') selectedBtn.querySelector('img').src = 'image/IconTankG.jpg';
        if (selectedBtn.id === 'uav-btn') selectedBtn.querySelector('img').src = 'image/IconUAVG.jpg';
        if (selectedBtn.id === 'jetfighter-btn') selectedBtn.querySelector('img').src = 'image/IconJetFighterG.jpg';
        if (selectedBtn.id === 'helicopter-btn') selectedBtn.querySelector('img').src = 'image/IconHelicopterG.jpg';
        if (selectedBtn.id === 'submarine-btn') selectedBtn.querySelector('img').src = 'image/IconSubmarineG.jpg';
        if (selectedBtn.id === 'battleship-btn') selectedBtn.querySelector('img').src = 'image/IconBattleshipG.jpg';
        selectedBtn.classList.remove('selected');
      }
      // Select new button
      placeMode = mode;
      // Turning on place mode cancels select mode
      if (isSelectMode) {
        isSelectMode = false;
        const selBtn = document.getElementById('select-mode-btn');
        if (selBtn) selBtn.classList.remove('selected');
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
      }
      // Toggle off measuring if active
      if (typeof measuring !== 'undefined' && measuring) {
        try { stopMeasuring(); } catch(_) {}
        const mImg = document.getElementById('measure-btn-img');
        if (mImg) mImg.src = 'image/IconRulerG.jpg';
        const mBtn = document.getElementById('measure-btn');
        if (mBtn) mBtn.style.backgroundColor = '#95a5a6';
      }
      try { updateMapLockByTools(); } catch(_) {}
    map.getContainer().style.cursor = 'crosshair';
  // Deactivate Move when a tool becomes active
  if (typeof deactivateMove === 'function') deactivateMove();
  // movement policy handled centrally by updateMapLockByTools()
      if (mode === 'tank') {
        selectedBtn = document.getElementById('tank-btn');
        selectedBtn.querySelector('img').src = 'image/IconTankL.jpg';
      } else if (mode === 'uav') {
        selectedBtn = document.getElementById('uav-btn');
        selectedBtn.querySelector('img').src = 'image/IconUAVL.jpg';
      } else if (mode === 'jetfighter') {
        selectedBtn = document.getElementById('jetfighter-btn');
        selectedBtn.querySelector('img').src = 'image/IconJetFighterL.jpg';
      } else if (mode === 'helicopter') {
        selectedBtn = document.getElementById('helicopter-btn');
        selectedBtn.querySelector('img').src = 'image/IconHelicopterL.jpg';
      } else if (mode === 'submarine') {
        selectedBtn = document.getElementById('submarine-btn');
        selectedBtn.querySelector('img').src = 'image/IconSubmarineL.jpg';
      } else if (mode === 'battleship') {
        selectedBtn = document.getElementById('battleship-btn');
        selectedBtn.querySelector('img').src = 'image/IconBattleshipL.jpg';
      }
      selectedBtn.classList.add('selected');
    }

    function clearPlaceMode() {
      if (selectedBtn) {
        if (selectedBtn.id === 'tank-btn') selectedBtn.querySelector('img').src = 'image/IconTankG.jpg';
        if (selectedBtn.id === 'uav-btn') selectedBtn.querySelector('img').src = 'image/IconUAVG.jpg';
        if (selectedBtn.id === 'jetfighter-btn') selectedBtn.querySelector('img').src = 'image/IconJetFighterG.jpg';
        if (selectedBtn.id === 'helicopter-btn') selectedBtn.querySelector('img').src = 'image/IconHelicopterG.jpg';
        if (selectedBtn.id === 'submarine-btn') selectedBtn.querySelector('img').src = 'image/IconSubmarineG.jpg';
        if (selectedBtn.id === 'battleship-btn') selectedBtn.querySelector('img').src = 'image/IconBattleshipG.jpg';
        selectedBtn.classList.remove('selected');
        selectedBtn = null;
      }
      placeMode = null;
      map.getContainer().style.cursor = '';
  // movement policy handled centrally by updateMapLockByTools()
      try { updateMapLockByTools(); } catch(_) {}
    }

    // Animate-on-draw mode: toggle per unit button
    function updateUnitButtonsVisual(activeType) {
      const mapImg = {
        tank: ['image/IconTankG.jpg','image/IconTankL.jpg'],
        uav: ['image/IconUAVG.jpg','image/IconUAVL.jpg'],
        jetfighter: ['image/IconJetFighterG.jpg','image/IconJetFighterL.jpg'],
        helicopter: ['image/IconHelicopterG.jpg','image/IconHelicopterL.jpg'],
        submarine: ['image/IconSubmarineG.jpg','image/IconSubmarineL.jpg'],
        battleship: ['image/IconBattleshipG.jpg','image/IconBattleshipL.jpg']
      };
      const ids = ['tank','uav','jetfighter','helicopter','submarine','battleship'];
      ids.forEach(id => {
        const btn = document.getElementById(id+'-btn');
        if (!btn) return;
        const img = btn.querySelector('img');
        if (!img) return;
        img.src = id === activeType ? mapImg[id][1] : mapImg[id][0];
      });
    }

    function setAnimDrawMode(type) {
      // Exit conflicting modes
      if (isSelectMode) {
        isSelectMode = false;
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
      }
      if (measuring) {
        stopMeasuring();
        const img = document.getElementById('measure-btn-img');
        if (img) img.src = 'image/IconRulerG.jpg';
        const btn = document.getElementById('measure-btn');
        if (btn) btn.style.backgroundColor = '#95a5a6';
      }
      if (drawingMode) {
        stopFreehandDraw();
        const drawImg = document.getElementById('draw-btn-img');
        if (drawImg) drawImg.src = 'image/IconDrawingG.jpg';
        const drawBtn = document.getElementById('draw-btn');
        if (drawBtn) drawBtn.style.backgroundColor = '#95a5a6';
        const palettePanel = document.getElementById('color-palette-panel');
        if (palettePanel) palettePanel.style.display = 'none';
      }
      // Clear placement mode if any
      clearPlaceMode();
      animDrawActive = true;
      animDrawUnitType = type;
      updateUnitButtonsVisual(type);
      map.getContainer().style.cursor = 'crosshair';
  // movement policy handled centrally by updateMapLockByTools()
      try { updateMapLockByTools(); } catch(_) {}
    }

    function clearAnimDrawMode() {
      animDrawActive = false;
      animDrawUnitType = null;
      updateUnitButtonsVisual(null);
      map.getContainer().style.cursor = '';
  // movement policy handled centrally by updateMapLockByTools()
      try { updateMapLockByTools(); } catch(_) {}
    }

    document.getElementById('tank-btn').onclick = function() { setRadioTool('anim:tank'); };
    document.getElementById('uav-btn').onclick = function() { setRadioTool('anim:uav'); };
    document.getElementById('jetfighter-btn').onclick = function() { setRadioTool('anim:jetfighter'); };
    document.getElementById('helicopter-btn').onclick = function() { setRadioTool('anim:helicopter'); };
    document.getElementById('submarine-btn').onclick = function() { setRadioTool('anim:submarine'); };
    document.getElementById('battleship-btn').onclick = function() { setRadioTool('anim:battleship'); };

    // Lock toggle button logic
    const lockBtn = document.getElementById('lock-map-btn');
    if (lockBtn) {
      lockBtn.addEventListener('click', function() {
        lockMapWhenToolActive = !lockMapWhenToolActive;
        this.textContent = lockMapWhenToolActive ? '' : '';
        // Do not override movement policy; just update icon then re-apply central rule
        try { updateMapLockByTools(); } catch(_) {}
      });
    }

    map.on('click', function(e) {
      if (animDrawActive) return; // block placement while anim-draw mode is active
      if (!placeMode) return;
      let icon;
      if (placeMode === 'tank') icon = tankIcon;
      if (placeMode === 'uav') icon = uavIcon;
      if (placeMode === 'jetfighter') icon = jetfighterIcon;
      if (placeMode === 'helicopter') icon = helicopterIcon;
      if (placeMode === 'submarine') icon = submarineIcon;
  if (placeMode === 'battleship') icon = battleshipIcon;
      if (icon) {
  const m = L.marker(e.latlng, {icon: icon, draggable: true}).addTo(map);
        m.unitType = placeMode;
        m.isSelected = false;
  m._headingDeg = 0;
  m.bindTooltip('<span class="heading-tip">0</span>', {permanent: false, direction: 'top', sticky: true, opacity: 0.9, offset: [0, -12], className: 'heading-tooltip'});
  allMarkers.push(m);
  // Add unit placement to undo history
  drawHistory.push(m);
  const undoImgP = document.getElementById('undo-btn-img');
  if (undoImgP) undoImgP.style.opacity = '1';
        // Click to toggle selection when in select mode
        m.on('click', function(ev) {
          if (!isSelectMode) return;
          if (ev && ev.originalEvent && L && L.DomEvent) { try { L.DomEvent.stopPropagation(ev); } catch(_){} }
          toggleUnitSelection(m);
          // Do not suppress; next explicit map click becomes the destination
          suppressNextMapClick = false;
        });
        // Directional drag for applicable unit types
        if (m.unitType === 'jetfighter' || m.unitType === 'tank' || m.unitType === 'uav' || m.unitType === 'submarine' || m.unitType === 'battleship' || m.unitType === 'helicopter') {
          attachDirectionalDrag(m);
        }
        // Do NOT clear placeMode here, so user can keep spawning icons
      }
    });

    // Keep icon heading consistent across pan/zoom
    map.on('zoomend moveend', function() {
      allMarkers.forEach(m => applyMarkerHeading(m));
    });

    function toggleUnitSelection(marker) {
      marker.isSelected = !marker.isSelected;
      if (marker._icon) {
        if (marker.isSelected) marker._icon.classList.add('unit-selected');
        else marker._icon.classList.remove('unit-selected');
      }
      const idx = selectedUnits.indexOf(marker);
      if (marker.isSelected && idx === -1) selectedUnits.push(marker);
      if (!marker.isSelected && idx !== -1) selectedUnits.splice(idx, 1);
    }

    // Select mode toggle
    document.getElementById('select-mode-btn').onclick = function() { setRadioTool('select'); };

    // Issue move command on map click in select mode (when not clicking a marker)
    map.on('click', function(e) {
      if (!isSelectMode) return;
      if (suppressNextMapClick) { suppressNextMapClick = false; return; }
      if (selectedUnits.length === 0) return;
      moveSelectedUnitsTo(e.latlng);
    });

    // Select-mode marquee selection (legacy handlers guarded when pointer is enabled)
    map.on('mousedown', function(e) {
      if (marqueePointerEnabled) return;
      if (!isSelectMode) return;
      if (e.originalEvent && e.originalEvent.button !== 0) return; // left button only
      marqueeActive = true;
      marqueeMoved = false;
      marqueeStart = e.latlng;
      map.dragging.disable();
      marqueeRect = L.rectangle([marqueeStart, marqueeStart], {
        color: '#00aaff',
        weight: 2,
        dashArray: '6,4',
        fillColor: '#00aaff',
        fillOpacity: 0.1,
        interactive: false
      }).addTo(map);
    });

    map.on('mousemove', function(e) {
      if (marqueePointerEnabled) return;
      if (!isSelectMode) return;
      if (!marqueeActive || !marqueeRect) return;
      const p0 = map.latLngToContainerPoint(marqueeStart);
      const p1 = map.latLngToContainerPoint(e.latlng);
      const dx = Math.abs(p1.x - p0.x);
      const dy = Math.abs(p1.y - p0.y);
      if (dx + dy > 5) marqueeMoved = true; // threshold to count as drag
      const bounds = L.latLngBounds(marqueeStart, e.latlng);
      marqueeRect.setBounds(bounds);
    });

    map.on('mouseup', function(e) {
      if (marqueePointerEnabled) return;
      if (!isSelectMode) return;
      if (!marqueeActive) return;
      map.dragging.enable();
      if (marqueeMoved && marqueeRect) {
        const bounds = marqueeRect.getBounds();
        while (selectedUnits.length) {
          const m = selectedUnits.pop();
          m.isSelected = false;
          if (m._icon) m._icon.classList.remove('unit-selected');
        }
        allMarkers.forEach(m => {
          if (bounds.contains(m.getLatLng())) {
            m.isSelected = true;
            if (m._icon) m._icon.classList.add('unit-selected');
            selectedUnits.push(m);
          }
        });
        suppressNextMapClick = true;
      }
      if (marqueeRect) { map.removeLayer(marqueeRect); marqueeRect = null; }
      marqueeActive = false;
      marqueeMoved = false;
      marqueeStart = null;
    });

    // Touch equivalents for select-mode marquee (guarded)
    map.on('touchstart', function(e) {
      if (marqueePointerEnabled) return;
      if (!isSelectMode) return;
      if (!e.originalEvent) return;
      const touch = e.originalEvent.touches && e.originalEvent.touches[0] ? e.originalEvent.touches[0] : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      e.originalEvent.preventDefault();
      marqueeActive = true;
      marqueeMoved = false;
      marqueeStart = latlng;
      map.dragging.disable();
      marqueeRect = L.rectangle([marqueeStart, marqueeStart], {
        color: '#00aaff',
        weight: 2,
        dashArray: '6,4',
        fillColor: '#00aaff',
        fillOpacity: 0.1,
        interactive: false
      }).addTo(map);
    });

    map.on('touchmove', function(e) {
      if (marqueePointerEnabled) return;
      if (!isSelectMode) return;
      if (!e.originalEvent) return;
      const touch = e.originalEvent.touches && e.originalEvent.touches[0] ? e.originalEvent.touches[0] : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      if (marqueeActive && marqueeRect) {
        e.originalEvent.preventDefault();
        const p0 = map.latLngToContainerPoint(marqueeStart);
        const p1 = map.latLngToContainerPoint(latlng);
        const dx = Math.abs(p1.x - p0.x);
        const dy = Math.abs(p1.y - p0.y);
        if (dx + dy > 5) marqueeMoved = true;
        const bounds = L.latLngBounds(marqueeStart, latlng);
        marqueeRect.setBounds(bounds);
      }
    });

    map.on('touchend', function(e) {
      if (marqueePointerEnabled) return;
      if (!isSelectMode) return;
      if (marqueeActive) {
        map.dragging.enable();
        if (marqueeMoved && marqueeRect) {
          const bounds = marqueeRect.getBounds();
          while (selectedUnits.length) {
            const m = selectedUnits.pop();
            m.isSelected = false;
            if (m._icon) m._icon.classList.remove('unit-selected');
          }
          allMarkers.forEach(m => {
            if (bounds.contains(m.getLatLng())) {
              m.isSelected = true;
              if (m._icon) m._icon.classList.add('unit-selected');
              selectedUnits.push(m);
            }
          });
          suppressNextMapClick = true;
        }
        if (marqueeRect) { map.removeLayer(marqueeRect); marqueeRect = null; }
        marqueeActive = false;
        marqueeMoved = false;
        marqueeStart = null;
      }
    });

    // Pointer-based marquee (unified)
    (function(){
      const c = map.getContainer();
      const MARQUEE_THRESHOLD_PX = 12; // require a meaningful drag before starting marquee
      let marqueePtrId = null;
      let marqueePrimed = false; // pointerdown happened, waiting to exceed threshold
      let marqueeStartPt = null; // container point at pointerdown
      function ptrToLatLng(ev){
        try { const r = c.getBoundingClientRect(); return map.containerPointToLatLng([ev.clientX - r.left, ev.clientY - r.top]); } catch(_) { return null; }
      }
      function onPtrDown(ev){
        if (!marqueePointerEnabled) return;
        if (!isSelectMode) return;
        if (ev.pointerType === 'mouse' && ev.button !== 0) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        const ll = ptrToLatLng(ev);
        if (!ll) return;
        marqueePtrId = ev.pointerId;
        marqueePrimed = true;
        marqueeActive = false; // not started yet until threshold passed
        marqueeMoved = false;
        marqueeStart = ll;
        marqueeStartPt = map.latLngToContainerPoint(ll);
      }
      function onPtrMove(ev){
        if (!marqueePointerEnabled) return;
        if (!isSelectMode) return;
        if (marqueePtrId == null || ev.pointerId !== marqueePtrId) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        const ll = ptrToLatLng(ev);
        if (!ll) return;
        const p1 = map.latLngToContainerPoint(ll);
        const dx = Math.abs(p1.x - (marqueeStartPt ? marqueeStartPt.x : p1.x));
        const dy = Math.abs(p1.y - (marqueeStartPt ? marqueeStartPt.y : p1.y));
        const movedEnough = Math.max(dx, dy) >= MARQUEE_THRESHOLD_PX;
        if (!marqueeActive) {
          if (!marqueePrimed) return;
          if (!movedEnough) return; // still a tap
          // Start marquee now
          marqueeActive = true;
          marqueeMoved = true;
          map.dragging.disable();
          marqueeRect = L.rectangle([marqueeStart, marqueeStart], {
            color: '#00aaff',
            weight: 2,
            dashArray: '6,4',
            fillColor: '#00aaff',
            fillOpacity: 0.1,
            interactive: false
          }).addTo(map);
        }
        // Update rectangle while dragging
        if (marqueeRect) {
          const bounds = L.latLngBounds(marqueeStart, ll);
          marqueeRect.setBounds(bounds);
        }
      }
      function endPtrGesture(){
        // Re-enable drag only if we had started marquee (we never disabled otherwise)
        if (marqueeActive) map.dragging.enable();
        if (marqueeActive && marqueeMoved && marqueeRect) {
          const bounds = marqueeRect.getBounds();
          while (selectedUnits.length) {
            const m = selectedUnits.pop();
            m.isSelected = false;
            if (m._icon) m._icon.classList.remove('unit-selected');
          }
          allMarkers.forEach(m => {
            if (bounds.contains(m.getLatLng())) {
              m.isSelected = true;
              if (m._icon) m._icon.classList.add('unit-selected');
              selectedUnits.push(m);
            }
          });
          // Suppress only the immediate synthetic click; auto-clear soon so next real tap works
          suppressNextMapClick = true;
          try { setTimeout(function(){ suppressNextMapClick = false; }, 250); } catch(_){}
        }
        if (marqueeRect) { map.removeLayer(marqueeRect); marqueeRect = null; }
        marqueeActive = false;
        marqueeMoved = false;
        marqueeStart = null;
        marqueePrimed = false;
        marqueePtrId = null;
        marqueeStartPt = null;
      }
      function onPtrUp(ev){
        if (!marqueePointerEnabled) return;
        if (!isSelectMode) return;
        if (marqueePtrId == null || ev.pointerId !== marqueePtrId) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        // If we never started marquee, treat it like a tap (let map click handler run)
        endPtrGesture();
      }
      function onPtrCancel(ev){
        if (!marqueePointerEnabled) return;
        if (!isSelectMode) return;
        if (marqueePtrId == null || ev.pointerId !== marqueePtrId) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        endPtrGesture();
      }
      try { c.addEventListener('pointerdown', onPtrDown, { passive: false }); } catch(_){}
      try { c.addEventListener('pointermove', onPtrMove, { passive: false }); } catch(_){}
      try { c.addEventListener('pointerup', onPtrUp, { passive: false }); } catch(_){}
      try { c.addEventListener('pointercancel', onPtrCancel, { passive: false }); } catch(_){}
    })();

    // Geodesic destination from center by distance (m) and bearing (deg)
    function destinationPoint(center, distance, bearingDeg) {
      const R = 6371000; // meters
      const br = bearingDeg * Math.PI / 180;
      const lat1 = center.lat * Math.PI / 180;
      const lon1 = center.lng * Math.PI / 180;
      const dr = distance / R;
      const sinLat1 = Math.sin(lat1), cosLat1 = Math.cos(lat1);
      const sinDr = Math.sin(dr), cosDr = Math.cos(dr);
      const sinLat2 = sinLat1 * cosDr + cosLat1 * sinDr * Math.cos(br);
      const lat2 = Math.asin(sinLat2);
      const y = Math.sin(br) * sinDr * cosLat1;
      const x = cosDr - sinLat1 * sinLat2;
      const lon2 = lon1 + Math.atan2(y, x);
      return L.latLng(lat2 * 180 / Math.PI, ((lon2 * 180 / Math.PI + 540) % 360) - 180);
    }

    function moveSelectedUnitsTo(destLatLng) {
      const DURATION_MS = 3000; // complete move within 3 seconds
      unitMoveJobs = [];
      const now = performance.now();

      const n = selectedUnits.length;
      const targets = [];
      if (n === 1) {
        targets.push(destLatLng);
      } else {
        const baseSpacing = 120; // meters between rings
        let remaining = n;
        let ring = 1;
        while (remaining > 0) {
          const capacity = 6 * ring; // 6, 12, 18, ...
          const onRing = Math.min(remaining, capacity);
          for (let j = 0; j < onRing; j++) {
            const angle = (360 / onRing) * j; // degrees
            targets.push(destinationPoint(destLatLng, baseSpacing * ring, angle));
          }
          remaining -= onRing;
          ring++;
        }
      }

      // Assign targets in order of selection
      selectedUnits.forEach((m, i) => {
        const target = targets[Math.min(i, targets.length - 1)];
        const from = m.getLatLng();
        const dist = map.distance(from, target);
        const duration = DURATION_MS; // constant duration for all
        unitMoveJobs.push({ marker: m, from, to: target, dist, start: now, duration });
      });
      if (!unitsAnimating) {
        unitsAnimLoop();
      }
    }

    function unitsAnimLoop() {
      unitsAnimating = true;
      const now = performance.now();
      let remaining = 0;
      unitMoveJobs.forEach(job => {
        const t = job.duration > 0 ? Math.min(1, (now - job.start) / job.duration) : 1;
        const lat = job.from.lat + (job.to.lat - job.from.lat) * t;
        const lng = job.from.lng + (job.to.lng - job.from.lng) * t;
        const a = job.from; const b = job.to;
        job.marker.setLatLng([lat, lng]);
  if (job.marker._icon && ['jetfighter','tank','uav','submarine','battleship','helicopter'].includes(job.marker.unitType)) {
          const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
          const angleDeg = angleRad * 180 / Math.PI;
          job.marker._headingDeg = angleDeg;
          applyMarkerHeading(job.marker);
          updateMarkerTooltip(job.marker);
        }
        if (t < 1) remaining++;
      });
      if (remaining > 0) {
        requestAnimationFrame(unitsAnimLoop);
      } else {
        unitsAnimating = false;
      }
    }

    

    

    // Animate-on-draw gesture (mouse)
    map.on('mousedown', function(e) {
      if (!animDrawActive || !animDrawUnitType) return;
      if (e && e.originalEvent) { e.originalEvent.preventDefault(); }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      animDrawPoints = [e.latlng];
      // Lock interactions during the draw gesture
      map.dragging.disable();
      map.touchZoom && map.touchZoom.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();
      map.boxZoom.disable();
      map.keyboard.disable();
      if (map.tap) map.tap.disable();
  if (animDrawTempLine) { try { tempDrawLayer.removeLayer(animDrawTempLine); } catch(_) {} animDrawTempLine = null; }
  animDrawTempLine = L.polyline(animDrawPoints, { color: '#ffffff', weight: 3, opacity: 0.1, temp: true }).addTo(tempDrawLayer);
    });

    map.on('mousemove', function(e) {
      if (!animDrawActive || animDrawPoints.length === 0) return;
      if (e && e.originalEvent) { e.originalEvent.preventDefault(); }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      animDrawPoints.push(e.latlng);
      if (animDrawTempLine) animDrawTempLine.setLatLngs(animDrawPoints);
    });

    map.on('mouseup', function(e) {
      if (!animDrawActive || animDrawPoints.length === 0) return;
  // Re-enable interactions
  map.dragging.enable();
  map.touchZoom && map.touchZoom.enable();
  map.doubleClickZoom.enable();
  map.scrollWheelZoom.enable();
  map.boxZoom.enable();
  map.keyboard.enable();
  if (map.tap) map.tap.enable();
      // Remove the drawn path immediately (disappear)
  if (animDrawTempLine) { try { tempDrawLayer.removeLayer(animDrawTempLine); } catch(_) {} animDrawTempLine = null; }
      const pts = animDrawPoints.slice();
      animDrawPoints = [];
      if (pts.length < 2) return;
      // Create a temporary marker for the chosen unit
      let icon = null;
      if (animDrawUnitType === 'tank') icon = tankIcon;
      if (animDrawUnitType === 'uav') icon = uavIcon;
      if (animDrawUnitType === 'jetfighter') icon = jetfighterIcon;
      if (animDrawUnitType === 'helicopter') icon = helicopterIcon;
      if (animDrawUnitType === 'submarine') icon = submarineIcon;
      if (animDrawUnitType === 'battleship') icon = battleshipIcon;
      if (!icon) return;
      const animMarker = L.marker(pts[0], { icon: icon, draggable: true }).addTo(map);
      animMarker.unitType = animDrawUnitType;
      animMarker.isSelected = false;
      animMarker._headingDeg = 0;
      animMarker.bindTooltip('<span class="heading-tip">0</span>', {permanent: false, direction: 'top', sticky: true, opacity: 0.9, offset: [0, -12], className: 'heading-tooltip'});
      // Enable selection by click in select mode
      animMarker.on('click', function(ev) {
        if (!isSelectMode) return;
        if (ev && ev.originalEvent && L && L.DomEvent) { try { L.DomEvent.stopPropagation(ev); } catch(_){} }
        toggleUnitSelection(animMarker);
        suppressNextMapClick = false;
      });
      // Drag rotation for supported units
      attachDirectionalDrag(animMarker);
  allMarkers.push(animMarker);
  // Allow undo of the animated unit creation
  drawHistory.push(animMarker);
  const undoImgAnim = document.getElementById('undo-btn-img');
  if (undoImgAnim) undoImgAnim.style.opacity = '1';
      // (removed duplicate bind/click/drag/push)
      const segDist = [];
      let total = 0;
      for (let i = 1; i < pts.length; i++) {
        const d = map.distance(pts[i-1], pts[i]);
        segDist.push(d);
        total += d;
      }
      const duration = 5000;
      const startTime = performance.now();
      function step(now) {
        let t = (now - startTime) / duration;
        if (t < 0) t = 0; if (t > 1) t = 1;
        const targetDist = total * t;
        let acc = 0;
        let si = 0;
        while (si < segDist.length && acc + segDist[si] < targetDist) { acc += segDist[si]; si++; }
        if (si >= segDist.length) { animMarker.setLatLng(pts[pts.length - 1]); return; }
        const a = pts[si];
        const b = pts[si + 1];
        const segLen = segDist[si];
        const segT = segLen > 0 ? (targetDist - acc) / segLen : 0;
        const lat = a.lat + (b.lat - a.lat) * segT;
        const lng = a.lng + (b.lng - a.lng) * segT;
        animMarker.setLatLng([lat, lng]);
        const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
        const angleDeg = angleRad * 180 / Math.PI;
        animMarker._headingDeg = angleDeg;
        const tStr = animMarker._icon && animMarker._icon.style.transform || '';
        const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
        if (animMarker._icon) {
          animMarker._icon.style.transform = `${cleaned} rotate(${angleDeg}deg)`;
          animMarker._icon.style.transformOrigin = '16px 16px';
        }
        if (t < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    });

    // Animate-on-draw gesture (touch)
    map.on('touchstart', function(e) {
      if (!animDrawActive || !animDrawUnitType) return;
      if (!e.originalEvent) return;
      try { e.originalEvent.preventDefault(); } catch(_){}
      try { if (L && L.DomEvent) L.DomEvent.stop(e.originalEvent); } catch(_){}
      const touch = e.originalEvent.touches && e.originalEvent.touches[0]
        ? e.originalEvent.touches[0]
        : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      if (!latlng) return;
      animDrawPoints = [latlng];
      // Lock interactions during gesture
      map.dragging.disable();
      map.touchZoom && map.touchZoom.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();
      map.boxZoom.disable();
      map.keyboard.disable();
      if (map.tap) map.tap.disable();
      if (animDrawTempLine) { try { tempDrawLayer.removeLayer(animDrawTempLine); } catch(_) {} animDrawTempLine = null; }
      animDrawTempLine = L.polyline(animDrawPoints, { color: '#ffffff', weight: 3, opacity: 0.1, temp: true }).addTo(tempDrawLayer);
    });

    map.on('touchmove', function(e) {
      if (!animDrawActive || animDrawPoints.length === 0) return;
      if (!e.originalEvent) return;
      try { e.originalEvent.preventDefault(); } catch(_){}
      try { if (L && L.DomEvent) L.DomEvent.stop(e.originalEvent); } catch(_){}
      const touch = e.originalEvent.touches && e.originalEvent.touches[0]
        ? e.originalEvent.touches[0]
        : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      if (!latlng) return;
      animDrawPoints.push(latlng);
      if (animDrawTempLine) animDrawTempLine.setLatLngs(animDrawPoints);
    });

    map.on('touchend', function(e) {
      if (!animDrawActive || animDrawPoints.length === 0) return;
      // Re-enable interactions
      map.dragging.enable();
      map.touchZoom && map.touchZoom.enable();
      map.doubleClickZoom.enable();
      map.scrollWheelZoom.enable();
      map.boxZoom.enable();
      map.keyboard.enable();
      if (map.tap) map.tap.enable();
      // Remove the drawn path immediately (disappear)
      if (animDrawTempLine) { try { tempDrawLayer.removeLayer(animDrawTempLine); } catch(_) {} animDrawTempLine = null; }
      const pts = animDrawPoints.slice();
      animDrawPoints = [];
      if (pts.length < 2) return;
      // Create a temporary marker for the chosen unit
      let icon = null;
      if (animDrawUnitType === 'tank') icon = tankIcon;
      if (animDrawUnitType === 'uav') icon = uavIcon;
      if (animDrawUnitType === 'jetfighter') icon = jetfighterIcon;
      if (animDrawUnitType === 'helicopter') icon = helicopterIcon;
      if (animDrawUnitType === 'submarine') icon = submarineIcon;
      if (animDrawUnitType === 'battleship') icon = battleshipIcon;
      if (!icon) return;
      const animMarker = L.marker(pts[0], { icon: icon, draggable: true }).addTo(map);
      animMarker.unitType = animDrawUnitType;
      animMarker.isSelected = false;
      animMarker._headingDeg = 0;
      animMarker.bindTooltip('<span class="heading-tip">0</span>', {permanent: false, direction: 'top', sticky: true, opacity: 0.9, offset: [0, -12], className: 'heading-tooltip'});
      // Enable selection by click in select mode
      animMarker.on('click', function(ev) {
        if (!isSelectMode) return;
        if (ev && ev.originalEvent && L && L.DomEvent) { try { L.DomEvent.stopPropagation(ev); } catch(_){} }
        toggleUnitSelection(animMarker);
        suppressNextMapClick = false;
      });
      // Drag rotation for supported units
      attachDirectionalDrag(animMarker);
      allMarkers.push(animMarker);
      // Allow undo of the animated unit creation
      drawHistory.push(animMarker);
      const undoImgAnim = document.getElementById('undo-btn-img');
      if (undoImgAnim) undoImgAnim.style.opacity = '1';
      // Follow path animation
      const segDist = [];
      let total = 0;
      for (let i = 1; i < pts.length; i++) {
        const d = map.distance(pts[i-1], pts[i]);
        segDist.push(d);
        total += d;
      }
      const duration = 5000;
      const startTime = performance.now();
      function step(now) {
        let t = (now - startTime) / duration;
        if (t < 0) t = 0; if (t > 1) t = 1;
        const targetDist = total * t;
        let acc = 0;
        let si = 0;
        while (si < segDist.length && acc + segDist[si] < targetDist) { acc += segDist[si]; si++; }
        if (si >= segDist.length) { animMarker.setLatLng(pts[pts.length - 1]); return; }
        const a = pts[si];
        const b = pts[si + 1];
        const segLen = segDist[si];
        const segT = segLen > 0 ? (targetDist - acc) / segLen : 0;
        const lat = a.lat + (b.lat - a.lat) * segT;
        const lng = a.lng + (b.lng - a.lng) * segT;
        animMarker.setLatLng([lat, lng]);
        const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
        const angleDeg = angleRad * 180 / Math.PI;
        animMarker._headingDeg = angleDeg;
        const tStr = animMarker._icon && animMarker._icon.style.transform || '';
        const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
        if (animMarker._icon) {
          animMarker._icon.style.transform = `${cleaned} rotate(${angleDeg}deg)`;
          animMarker._icon.style.transformOrigin = '16px 16px';
        }
        if (t < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    });

    // Animate-on-draw gesture (Pointer Events) for touch/pen on Windows and modern browsers
    (function(){
      const c = map.getContainer();
      let animPointerId = null;
      function getLatLngFromPointer(ev){
        try {
          const rect = c.getBoundingClientRect();
          return map.containerPointToLatLng([ev.clientX - rect.left, ev.clientY - rect.top]);
        } catch(_) { return null; }
      }
      function onPtrDown(ev){
        // Only handle non-mouse pointers here to avoid double-handling with mouse handlers
        if (ev.pointerType === 'mouse') return;
        if (!animDrawActive || !animDrawUnitType) return;
        if (ev.isPrimary === false) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        const ll = getLatLngFromPointer(ev);
        if (!ll) return;
        animPointerId = ev.pointerId;
        animDrawPoints = [ll];
        // Lock interactions during the draw gesture
        map.dragging.disable();
        map.touchZoom && map.touchZoom.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.boxZoom.disable();
        map.keyboard.disable();
        if (map.tap) map.tap.disable();
        if (animDrawTempLine) { try { tempDrawLayer.removeLayer(animDrawTempLine); } catch(_) {} animDrawTempLine = null; }
        animDrawTempLine = L.polyline(animDrawPoints, { color: '#ffffff', weight: 3, opacity: 0.1, temp: true }).addTo(tempDrawLayer);
      }
      function onPtrMove(ev){
        if (ev.pointerType === 'mouse') return;
        if (!animDrawActive || animPointerId == null || ev.pointerId !== animPointerId) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        const ll = getLatLngFromPointer(ev);
        if (!ll) return;
        animDrawPoints.push(ll);
        if (animDrawTempLine) animDrawTempLine.setLatLngs(animDrawPoints);
      }
      function finalizeAnimGesture(){
        // Re-enable interactions
        map.dragging.enable();
        map.touchZoom && map.touchZoom.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.boxZoom.enable();
        map.keyboard.enable();
        if (map.tap) map.tap.enable();
        // Remove the drawn path immediately (disappear)
        if (animDrawTempLine) { try { tempDrawLayer.removeLayer(animDrawTempLine); } catch(_) {} animDrawTempLine = null; }
        const pts = animDrawPoints.slice();
        animDrawPoints = [];
        if (!pts || pts.length < 2) return;
        // Create a temporary marker for the chosen unit
        let icon = null;
        if (animDrawUnitType === 'tank') icon = tankIcon;
        if (animDrawUnitType === 'uav') icon = uavIcon;
        if (animDrawUnitType === 'jetfighter') icon = jetfighterIcon;
        if (animDrawUnitType === 'helicopter') icon = helicopterIcon;
        if (animDrawUnitType === 'submarine') icon = submarineIcon;
        if (animDrawUnitType === 'battleship') icon = battleshipIcon;
        if (!icon) return;
        const animMarker = L.marker(pts[0], { icon: icon, draggable: true }).addTo(map);
        animMarker.unitType = animDrawUnitType;
        animMarker.isSelected = false;
        animMarker._headingDeg = 0;
        animMarker.bindTooltip('<span class="heading-tip">0</span>', {permanent: false, direction: 'top', sticky: true, opacity: 0.9, offset: [0, -12], className: 'heading-tooltip'});
        // Enable selection by click in select mode
        animMarker.on('click', function(ev) {
          if (!isSelectMode) return;
          if (ev && ev.originalEvent && L && L.DomEvent) { try { L.DomEvent.stopPropagation(ev); } catch(_){} }
          toggleUnitSelection(animMarker);
          suppressNextMapClick = false;
        });
        // Drag rotation for supported units
        attachDirectionalDrag(animMarker);
        allMarkers.push(animMarker);
        // Allow undo of the animated unit creation
        drawHistory.push(animMarker);
        const undoImgAnim = document.getElementById('undo-btn-img');
        if (undoImgAnim) undoImgAnim.style.opacity = '1';
        // Follow path animation
        const segDist = [];
        let total = 0;
        for (let i = 1; i < pts.length; i++) {
          const d = map.distance(pts[i-1], pts[i]);
          segDist.push(d);
          total += d;
        }
        const duration = 5000;
        const startTime = performance.now();
        function step(now) {
          let t = (now - startTime) / duration;
          if (t < 0) t = 0; if (t > 1) t = 1;
          const targetDist = total * t;
          let acc = 0;
          let si = 0;
          while (si < segDist.length && acc + segDist[si] < targetDist) { acc += segDist[si]; si++; }
          if (si >= segDist.length) { animMarker.setLatLng(pts[pts.length - 1]); return; }
          const a = pts[si];
          const b = pts[si + 1];
          const segLen = segDist[si];
          const segT = segLen > 0 ? (targetDist - acc) / segLen : 0;
          const lat = a.lat + (b.lat - a.lat) * segT;
          const lng = a.lng + (b.lng - a.lng) * segT;
          animMarker.setLatLng([lat, lng]);
          const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
          const angleDeg = angleRad * 180 / Math.PI;
          animMarker._headingDeg = angleDeg;
          const tStr = animMarker._icon && animMarker._icon.style.transform || '';
          const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
          if (animMarker._icon) {
            animMarker._icon.style.transform = `${cleaned} rotate(${angleDeg}deg)`;
            animMarker._icon.style.transformOrigin = '16px 16px';
          }
          if (t < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      }
      function onPtrUp(ev){
        if (ev.pointerType === 'mouse') return;
        if (animPointerId == null || ev.pointerId !== animPointerId) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        animPointerId = null;
        finalizeAnimGesture();
      }
      function onPtrCancel(ev){
        if (ev.pointerType === 'mouse') return;
        if (animPointerId == null || ev.pointerId !== animPointerId) return;
        try { ev.preventDefault(); } catch(_){}
        try { ev.stopPropagation(); } catch(_){}
        animPointerId = null;
        finalizeAnimGesture();
      }
      try { c.addEventListener('pointerdown', onPtrDown, { passive: false }); } catch(_){}
      try { c.addEventListener('pointermove', onPtrMove, { passive: false }); } catch(_){}
      try { c.addEventListener('pointerup', onPtrUp, { passive: false }); } catch(_){}
      try { c.addEventListener('pointercancel', onPtrCancel, { passive: false }); } catch(_){}
    })();

    // Memorize and go to location logic
    // Load memorized locations from localStorage
    function loadMemorized() {
      try {
        const saved = localStorage.getItem('memorizedLocations');
        if (saved) {
          const arr = JSON.parse(saved);
          // Convert center back to LatLng objects
          return arr.map(loc => {
            if (!loc) return null;
            return {
              ...loc,
              center: L.latLng(loc.center.lat, loc.center.lng)
            };
          });
        }
      } catch (e) {}
      return [null, null, null, null, null];
    }

    function saveMemorized() {
      localStorage.setItem('memorizedLocations', JSON.stringify(memorized));
    }

    var memorized = loadMemorized();
    var currentMode = 'memorize'; // Default to memorize mode
    
    // Function to get elevation from coordinates
    async function getElevation(lat, lng) {
      try {
        // Using Open-Elevation API (free service)
        const response = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`);
        const data = await response.json();
        if (data.results && data.results.length > 0) {
          return data.results[0].elevation;
        }
        return null;
      } catch (error) {
        console.log('Elevation service unavailable, using map zoom as approximation');
        // Fallback: approximate elevation based on zoom level (very rough estimate)
        const zoom = map.getZoom();
        return Math.max(0, (20 - zoom) * 100); // Rough approximation
      }
    }
    
    async function memorize(idx) {
      const center = map.getCenter();
      const zoom = map.getZoom();
      
      // Show loading message
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = 'Getting elevation data...';
      loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:10px;border-radius:5px;z-index:9999;';
      document.body.appendChild(loadingMsg);
      
      try {
        const elevation = await getElevation(center.lat, center.lng);
        memorized[idx] = {
          center: center,
          zoom: zoom,
          elevation: elevation,
          timestamp: new Date().toLocaleString()
        };
        saveMemorized();
  document.body.removeChild(loadingMsg);
  updateLocationButtons(); // Update button appearance
  showToast(`Saved Location ${idx+1}`);
      } catch (error) {
        document.body.removeChild(loadingMsg);
        alert('Error getting elevation data. Location saved without elevation.');
        memorized[idx] = {
          center: center,
          zoom: zoom,
          elevation: null,
          timestamp: new Date().toLocaleString()
        };
        saveMemorized();
        updateLocationButtons();
      }
    }
    
    function goTo(idx) {
      if (!memorized[idx]) {
        alert('No location memorized for '+(idx+1));
        return;
      }
  const target = memorized[idx];
  const elevationText = target.elevation !== null ? `${Math.round(target.elevation)}m` : 'Unknown';

      // Preload tiles for smoother fly-in
      preloadTiles(target.center, target.zoom).then(() => {
        map.setView(target.center, target.zoom, {animate: true, duration: 2});
      });
    }

    // Preload tiles for a given center and zoom
    function preloadTiles(center, zoom) {
      return new Promise(resolve => {
        try {
          const layer = window.__baseTileLayer;
          const tileSize = layer && layer.getTileSize ? layer.getTileSize().x : 256;
          const p = map.project(center, zoom);
          const tileX = Math.floor(p.x / tileSize);
          const tileY = Math.floor(p.y / tileSize);
          const max = 1 << zoom;
          const promises = [];
          for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
              const x = ((tileX + dx) % max + max) % max; // wrap X
              const y = Math.min(max - 1, Math.max(0, tileY + dy));
              const url = layer ? layer.getTileUrl({x, y, z: zoom}) : '';
              if (!url) continue;
              promises.push(fetch(url, { cache: 'force-cache' }).catch(function(){}));
            }
          }
          Promise.all(promises).then(function(){ setTimeout(resolve, 150); });
        } catch (_) {
          resolve();
        }
      });
    }
    
    function showAllLocations() {
      let locationList = 'Memorized Locations:\n\n';
      let hasLocations = false;
      
      for (let i = 0; i < 5; i++) {
        if (memorized[i]) {
          hasLocations = true;
          const loc = memorized[i];
          const elevationText = loc.elevation !== null ? `${Math.round(loc.elevation)}m` : 'Unknown';
          locationList += `Map ${i+1}:\n`;
          locationList += `  Coordinates: ${loc.center.lat.toFixed(6)}, ${loc.center.lng.toFixed(6)}\n`;
          locationList += `  Elevation: ${elevationText}\n`;
          locationList += `  Zoom Level: ${loc.zoom}\n`;
          locationList += `  Saved: ${loc.timestamp}\n\n`;
        }
      }
      
      if (!hasLocations) {
        alert('No locations have been memorized yet.');
      } else {
        alert(locationList);
      }
    }
    
    function updateLocationButtons() {
      for (let i = 1; i <= 5; i++) {
        const btn = document.getElementById('location-' + i);
        const img = document.getElementById('location-img-' + i);
        const isMemorized = memorized[i-1] !== null;
        if (currentMode === 'memorize') {
          img.src = 'image/IconMapR.jpg';
        } else {
          img.src = isMemorized ? 'image/IconMapL.jpg' : 'image/IconMapG.jpg';
        }
        btn.className = 'location-btn';
        btn.style.opacity = currentMode === 'go' && !isMemorized ? '0.5' : '1';
      }
      saveMemorized(); // Save state on every update
    }
    
    function handleLocationClick(index) {
      if (currentMode === 'memorize') {
        memorize(index);
      } else {
        goTo(index);
      }
    }
    
    // Set up location button event listeners
    for (let i = 1; i <= 5; i++) {
      document.getElementById('location-' + i).onclick = function() {
        handleLocationClick(i - 1);
      };
    }
    
    // Mode switch icon logic
    function setMode(mode) {
      currentMode = mode;
      updateLocationButtons();
      // Update icons
      if (mode === 'memorize') {
        document.getElementById('mode-memorize').classList.add('selected');
        document.getElementById('mode-go').classList.remove('selected');
        document.getElementById('mode-memorize-img').src = 'image/IconSaveL.jpg';
        document.getElementById('mode-go-img').src = 'image/IconGotoMapG.jpg';
      } else {
        document.getElementById('mode-go').classList.add('selected');
        document.getElementById('mode-memorize').classList.remove('selected');
        document.getElementById('mode-memorize-img').src = 'image/IconSaveG.jpg';
        document.getElementById('mode-go-img').src = 'image/IconGotoMapL.jpg';
      }
    }

    document.getElementById('mode-memorize').onclick = function() { setMode('memorize'); };
    document.getElementById('mode-go').onclick = function() { setMode('go'); };

    // Measuring tool variables
    var measuring = false;
    var measurePoints = [];
    var measureLine = null;
    var measureMarkers = [];
    var measureTooltip = null;

    function startMeasuring() {
      measuring = true;
      measurePoints = [];
      if (measureLine) { map.removeLayer(measureLine); measureLine = null; }
      measureMarkers.forEach(m => map.removeLayer(m));
      measureMarkers = [];
      if (measureTooltip) { map.removeLayer(measureTooltip); measureTooltip = null; }
      map.getContainer().style.cursor = 'crosshair';
  // Do not disable other tools; allow switching like radio buttons
      // Exit select mode
      if (typeof isSelectMode !== 'undefined' && isSelectMode) {
        isSelectMode = false;
        const selBtn = document.getElementById('select-mode-btn');
        if (selBtn) selBtn.classList.remove('selected');
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
      }
      // Exit placement
      clearPlaceMode();
      // Exit animate-on-draw
      if (typeof animDrawActive !== 'undefined' && animDrawActive) {
        clearAnimDrawMode();
        if (typeof animDrawTempLine !== 'undefined' && animDrawTempLine) { try { map.removeLayer(animDrawTempLine); } catch(_){} animDrawTempLine = null; }
        if (typeof animDrawPoints !== 'undefined') animDrawPoints = [];
      }
      // Exit freehand drawing
      if (typeof drawingMode !== 'undefined' && drawingMode) {
        stopFreehandDraw();
        const drawImg = document.getElementById('draw-btn-img');
        if (drawImg) drawImg.src = 'image/IconDrawingG.jpg';
        const drawBtn = document.getElementById('draw-btn');
        if (drawBtn) drawBtn.style.backgroundColor = '#95a5a6';
        const palettePanel = document.getElementById('color-palette-panel');
        if (palettePanel) palettePanel.style.display = 'none';
      }
    // Lock map interactions while measuring
    map.dragging.disable();
    if (map.touchZoom) map.touchZoom.disable();
    map.doubleClickZoom.disable();
    map.scrollWheelZoom.disable();
    map.boxZoom.disable();
    map.keyboard.disable();
    if (map.tap) map.tap.disable();
    }

    function stopMeasuring() {
      measuring = false;
      map.getContainer().style.cursor = '';
  // Keep other tools enabled (radio behavior)
  // Restore interactions
  map.dragging.enable();
  if (map.touchZoom) map.touchZoom.enable();
  map.doubleClickZoom.enable();
  map.scrollWheelZoom.enable();
  map.boxZoom.enable();
  map.keyboard.enable();
  if (map.tap) map.tap.enable();
    }

    // Measuring no longer disables other tool buttons; it behaves like radio with other tools

    function updateMeasure() {
      if (measureLine) { map.removeLayer(measureLine); measureLine = null; }
      measureMarkers.forEach(m => map.removeLayer(m));
      measureMarkers = [];
      if (measurePoints.length > 1) {
        measureLine = L.polyline(measurePoints, {color: '#ffffff', weight: 2, dashArray: '6,6', opacity: 0.9}).addTo(map);
      }
      measurePoints.forEach((pt, i) => {
        var marker = L.circleMarker(pt, {radius: 4, color: '#ffffff', fillColor: '#000000', fillOpacity: 0.8, weight: 1}).addTo(map);
        measureMarkers.push(marker);
      });
      // Tooltip for total distance
      if (measureTooltip) { map.removeLayer(measureTooltip); measureTooltip = null; }
      if (measurePoints.length > 1) {
        var dist = 0;
        for (var i=1; i<measurePoints.length; i++) {
          dist += map.distance(measurePoints[i-1], measurePoints[i]);
        }
        var last = measurePoints[measurePoints.length-1];
        var distText = dist >= 1000 ? (dist/1000).toFixed(2) + ' km' : dist.toFixed(1) + ' m';
        measureTooltip = L.popup({closeButton:false, autoClose:false, className:'measure-popup'})
          .setLatLng(last)
          .setContent('<b>' + distText + '</b>')
          .addTo(map);
      }
    }

    document.getElementById('measure-btn').onclick = function() { setRadioTool('measure'); };

    map.on('click', function(e) {
      if (measuring) {
        measurePoints.push(e.latlng);
        updateMeasure();
      }
    });

    map.on('dblclick', function(e) {
      if (measuring) {
        stopMeasuring();
        document.getElementById('measure-btn').textContent = 'Measure Distance';
        document.getElementById('measure-btn').style.backgroundColor = '#95a5a6';
        // Do NOT clear measurement visuals here
      }
    });

    // Initialize button appearance
    updateLocationButtons();

    // Palette visibility is handled inside draw start/stop and button handler

    // Pen color selection logic (persisted)
    var penColor = (function(){ try { return localStorage.getItem('penColor') || '#ff0000'; } catch(_){ return '#ff0000'; } })();
    function updatePaletteSelection(){
      try {
        var buttons = document.querySelectorAll('.palette-color-btn');
        buttons.forEach(function(b){ b.style.outline = ''; });
        buttons.forEach(function(b){ if (b.getAttribute('data-color') === penColor) { b.style.outline = '2px solid #333'; } });
      } catch(_){}
    }
    document.querySelectorAll('.palette-color-btn').forEach(function(btn) {
      btn.onclick = function() {
        penColor = btn.getAttribute('data-color');
        try { localStorage.setItem('penColor', penColor); } catch(_){ }
        updatePaletteSelection();
      };
    });
    // Initialize palette selection on load
    try { updatePaletteSelection(); } catch(_){}

    // penColor is applied in mouse/touch drawing handlers above

    // Keyboard shortcuts
    // Ctrl+B: toggle country borders; Ctrl+D: toggle debug overlay
    window.addEventListener('keydown', function(e){
      try {
        if (!e.ctrlKey || e.shiftKey || e.altKey) return;
        if (e.code === 'KeyB') {
          e.preventDefault();
          toggleBorders();
        } else if (e.code === 'KeyD') {
          e.preventDefault();
          const dbg = document.getElementById('debug-overlay');
          if (!dbg) return;
          const hidden = getComputedStyle(dbg).display === 'none';
          dbg.style.display = hidden ? 'flex' : 'none';
          try { showToast('Debug: ' + (hidden ? 'ON' : 'OFF')); } catch(_){}
        }
      } catch(_){ }
    }, { passive: false });
  </script>
</body>
</html>