<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    #debug-console {
      position: fixed;
      left: 10px;
      bottom: 10px;
      width: 350px;
      max-height: 200px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-family: monospace;
      font-size: 13px;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      z-index: 9999;
      overflow-y: auto;
      padding: 10px;
    }
  </style>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>World Satellite Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />
  <style>
    #map {
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
    }
    body {
      margin: 0;
      padding: 0;
    }
    .control-panel {
      position: absolute;
      z-index: 1000;
      right: 400px;
      top: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 0;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-family: Arial, sans-serif;
      position: absolute;
      z-index: 1000;
      right: 400px;
      top: 10px;
      background-image: initial;
      background-position-x: initial;
      background-position-y: initial;
      background-size: initial;
      background-repeat: initial;
      background-attachment: initial;
      background-origin: initial;
      background-clip: initial;
      background-color: rgba(255, 255, 255, 0.9);
      padding-top: 10px;
      padding-right: 10px;
      padding-bottom: 10px;
      padding-left: 10px;
      border-top-left-radius: 0px;
      border-top-right-radius: 0px;
      border-bottom-right-radius: 0px;
      border-bottom-left-radius: 0px;
      box-shadow: rgba(0, 0, 0, 0.2) 0px 2px 10px;
      font-family: Arial, sans-serif;
      right: 10px;
      width: 32px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .location-buttons {
      display: flex;
      flex-direction: column;
      gap: 0px !important;
      row-gap: 0px !important;
      align-items: center;
      margin-bottom: 0px;
    }
    .location-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 56px;
      height: 56px;
      padding: 0;
      border: none;
      border-radius: 0;
      background: none;
      cursor: pointer;
      margin: 0;
    }
    .map-btn-img {
      position: relative;
      display: inline-block;
      width: 32px;
      height: 32px;
    }
    .map-btn-img img {
      width: 32px;
      height: 32px;
      display: block;
    }
    .map-btn-num {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.3em;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 4px #000, 0 0 2px #333;
      pointer-events: none;
    }
    .location-btn.memorize-mode {
      background-color: #e74c3c;
      color: white;
    }
    .location-btn.memorize-mode:hover {
      background-color: #c0392b;
    }
    .location-btn.go-mode {
      background-color: #3498db;
      color: white;
    }
    .location-btn.go-mode:hover {
      background-color: #2980b9;
    }
    .other-buttons {
      display: flex;
      flex-direction: column;
      gap: 0px;
      align-items: flex-start;
      margin-top: 10px;
    }
    .other-buttons button {
      display: flex;
      align-items: center;
      width: 48px;
      height: 48px;
      padding: 0;
      border: none;
      border-radius: 0px;
      background: none;
      cursor: pointer;
    }
    .other-buttons button:hover {
      background-color: #7f8c8d;
    }
    #drawing-panel {
      top: 80px;
      right: 70px;
      width: 32px;
    }
    #mode-panel {
      top: 10px;
      right: 10px;
      width: 92px;
    }
    #map-panel {
      top: 80px;
      right: 10px;
      width: 32px;
    }
    #action-mode-panel {
      position: absolute;
      z-index: 1000;
      right: 200px;
      top: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 0;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-family: Arial, sans-serif;
    }
    .action-mode-switch {
      display: flex;
      flex-direction: column;
      gap: 0px;
      align-items: flex-start;
    }
    .action-mode-switch button {
      width: 90px;
      height: 32px;
      font-size: 1em;
      cursor: pointer;
      border: none;
      background: #eee;
      margin-bottom: 4px;
    }
    .action-mode-switch button.selected {
      background: #3498db;
      color: white;
    }
    .color-palette-buttons {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: center;
    }
    .palette-color-btn {
      width: 32px;
      height: 32px;
      border: none;
      cursor: pointer;
      position: relative;
    }
    .palette-color-btn:hover {
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }
    .palette-color-btn.selected {
      border: 2px solid #333;
    }
    /* Selection highlight for units */
    .leaflet-marker-icon.unit-selected {
      filter: drop-shadow(0 0 6px yellow) brightness(1.15);
    }
  </style>
</head>
<body>
  <div id="debug-console"></div>
  <div class="control-panel" id="drawing-panel">
    <div class="location-buttons">
      <button id="draw-btn" style="padding:0;border:none;background:none;">
        <img id="draw-btn-img" src="image/IconDrawingG.jpg" alt="Freehand Draw" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="clear-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconClearG.jpg" alt="Clear Drawings" style="width:32px;height:32px;vertical-align:middle;">
      </button>
    </div>
  </div>

  <div class="control-panel" id="tools-panel" style="top: 175px; right: 70px; width: 32px;">
    <div class="location-buttons">
      <button id="measure-btn" style="padding:0;border:none;background:none;">
        <img id="measure-btn-img" src="image/IconRulerG.jpg" alt="Measure Distance" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="tank-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconTankG.jpg" alt="Tank Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="uav-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconUAVG.jpg" alt="UAV Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="jetfighter-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconJetFighterG.jpg" alt="JetFighter Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="helicopter-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconHelicopterG.jpg" alt="Helicopter Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="submarine-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconSubmarineG.jpg" alt="Submarine Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="battleship-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconBattleshipG.jpg" alt="Battleship Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="select-mode-btn" title="Select units" style="padding:0;border:none;background:none;width:32px;height:32px;line-height:32px;text-align:center;">
        <img id="select-mode-btn-img" src="image/IconSelectRectangleG.jpg" alt="Select Units" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="animate-path-btn" title="Animate along path" style="padding:0;border:none;background:none;width:32px;height:32px;line-height:32px;font-size:22px;text-align:center;">â–¶</button>
    </div>
  </div>
  <div class="control-panel" id="map-panel">
    <div class="location-buttons">
      <button class="location-btn" id="location-1"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-1" style="width:32px;height:32px;"><span class="map-btn-num" id="location-num-1">1</span></span></button>
      <button class="location-btn" id="location-2"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-2" style="width:32px;height:32px;"><span class="map-btn-num" id="location-num-2">2</span></span></button>
      <button class="location-btn" id="location-3"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-3" style="width:32px;height:32px;"><span class="map-btn-num" id="location-num-3">3</span></span></button>
      <button class="location-btn" id="location-4"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-4" style="width:32px;height:32px;"><span class="map-btn-num" id="location-num-4">4</span></span></button>
      <button class="location-btn" id="location-5"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-5" style="width:32px;height:32px;"><span class="map-btn-num" id="location-num-5">5</span></span></button>
    </div>
  </div>
  <div class="control-panel" id="mode-panel">
    <div class="mode-switch">
      <button id="mode-memorize" style="padding:0;border:none;background:none;outline:none;">
        <img id="mode-memorize-img" src="image/IconSaveL.jpg" alt="Memorize Mode" style="width:40px;height:40px;vertical-align:middle;">
      </button>
      <button id="mode-go" style="padding:0;border:none;background:none;outline:none;">
        <img id="mode-go-img" src="image/IconGotoMapG.jpg" alt="Go Mode" style="width:40px;height:40px;vertical-align:middle;">
      </button>
    </div>
  </div>
  <div class="control-panel" id="color-palette-panel" style="top: 80px; right: 130px; width: 40px; display: none;">
    <div class="color-palette-buttons">
      <button class="palette-color-btn" data-color="#ff0000" title="Red" style="background:#ff0000;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#00ff00" title="Green" style="background:#00ff00;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#0000ff" title="Blue" style="background:#0000ff;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#000000" title="Black" style="background:#000000;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#ffffff" title="White" style="background:#ffffff;width:32px;height:32px;border:1px solid #ccc;margin-bottom:4px;"></button>
    </div>
  </div>
  <!-- action-mode-panel removed as requested -->
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
  <script>
    // Debug console logging
    function debugLog(msg) {
      var debugDiv = document.getElementById('debug-console');
      if (debugDiv) {
        var entry = document.createElement('div');
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        debugDiv.appendChild(entry);
        debugDiv.scrollTop = debugDiv.scrollHeight;
      }
      console.log(msg);
    }
    // Map setup
    var map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 19,
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    }).addTo(map);

    // Remove Leaflet attribution control
    map.attributionControl.remove();

    // Freehand drawing setup
    var drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);
  var lastDrawnPath = null; // stores the most recent freehand polyline
    
    // Freehand drawing variables
    var isDrawing = false;
    var currentPath = [];
    var drawingMode = false;
    
    // Freehand drawing functions
    function startFreehandDraw() {
      drawingMode = true;
      map.getContainer().style.cursor = 'crosshair';
      map.dragging.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();
      map.boxZoom.disable();
      map.keyboard.disable();
    }
    
    function stopFreehandDraw() {
      drawingMode = false;
      isDrawing = false;
      currentPath = [];
      map.getContainer().style.cursor = '';
      map.dragging.enable();
      map.doubleClickZoom.enable();
      map.scrollWheelZoom.enable();
      map.boxZoom.enable();
      map.keyboard.enable();
    }
    
    function clearAllDrawings() {
      drawnItems.clearLayers();
      if (measureLine) { map.removeLayer(measureLine); measureLine = null; }
      measureMarkers.forEach(m => map.removeLayer(m));
      measureMarkers = [];
      if (measureTooltip) { map.removeLayer(measureTooltip); measureTooltip = null; }
      measurePoints = [];
    }
    
    // Mouse event handlers for freehand drawing
    map.on('mousedown', function(e) {
      if (!drawingMode) return;
      isDrawing = true;
      currentPath = [e.latlng];
    });
    
    map.on('mousemove', function(e) {
      if (!drawingMode || !isDrawing) return;
      currentPath.push(e.latlng);

      // Remove previous temporary line
      map.eachLayer(function(layer) {
        if (layer.options && layer.options.temp) {
          map.removeLayer(layer);
        }
      });

      // Add new temporary line
      L.polyline(currentPath, {
        color: penColor, // <-- use penColor here
        weight: 3,
        opacity: 0.7,
        temp: true
      }).addTo(map);
    });
    
    map.on('mouseup', function(e) {
      if (!drawingMode || !isDrawing) return;
      isDrawing = false;

      if (currentPath.length > 1) {
        // Remove temporary line
        map.eachLayer(function(layer) {
          if (layer.options && layer.options.temp) {
            map.removeLayer(layer);
          }
        });

        // Add final polyline to drawn items
        var finalLine = L.polyline(currentPath, {
          color: penColor, // <-- use penColor here
          weight: 3,
          opacity: 1
        });
        drawnItems.addLayer(finalLine);
        lastDrawnPath = finalLine; // remember this path
      }

      currentPath = [];
    });
    
    // Touch event handlers for mobile devices
    map.on('touchstart', function(e) {
      if (!drawingMode) return;
      e.originalEvent.preventDefault();
      isDrawing = true;
      var touch = e.originalEvent.touches[0];
      var latlng = map.containerPointToLatLng([touch.clientX, touch.clientY]);
      currentPath = [latlng];
    });
    
    map.on('touchmove', function(e) {
      if (!drawingMode || !isDrawing) return;
      e.originalEvent.preventDefault();
      var touch = e.originalEvent.touches[0];
      var latlng = map.containerPointToLatLng([touch.clientX, touch.clientY]);
      currentPath.push(latlng);
      
      if (currentPath.length > 1) {
        map.eachLayer(function(layer) {
          if (layer.options && layer.options.temp) {
            map.removeLayer(layer);
          }
        });
        
        L.polyline(currentPath, {
          color: '#ff0000',
          weight: 3,
          opacity: 0.7,
          temp: true
        }).addTo(map);
      }
    });
    
    map.on('touchend', function(e) {
      if (!drawingMode || !isDrawing) return;
      e.originalEvent.preventDefault();
      isDrawing = false;
      
      if (currentPath.length > 1) {
        map.eachLayer(function(layer) {
          if (layer.options && layer.options.temp) {
            map.removeLayer(layer);
          }
        });
        
        var finalLine = L.polyline(currentPath, {
          color: '#ff0000',
          weight: 3,
          opacity: 1
        });
        drawnItems.addLayer(finalLine);
        lastDrawnPath = finalLine; // remember this path
      }
      
      currentPath = [];
    });

    // Button logic
    document.getElementById('draw-btn').onclick = function() {
      var img = document.getElementById('draw-btn-img');
      if (drawingMode) {
        stopFreehandDraw();
        img.src = 'image/IconDrawingG.jpg';
        img.alt = 'Freehand Draw';
        this.style.backgroundColor = '#95a5a6';
      } else {
        startFreehandDraw();
        img.src = 'image/IconDrawingL.jpg';
        img.alt = 'Stop Drawing';
        this.style.backgroundColor = '#e74c3c';
      }
    };
    
    document.getElementById('clear-btn').onclick = function() {
      clearAllDrawings();
      if (drawingMode) {
        stopFreehandDraw();
        var img = document.getElementById('draw-btn-img');
        img.src = 'image/IconDrawingG.jpg';
        img.alt = 'Freehand Draw';
        document.getElementById('draw-btn').style.backgroundColor = '#95a5a6';
      }
    };
    
    // Icon definitions
    var tankIcon = L.icon({
      iconUrl: 'image/IconTankMap.png',
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });
    var uavIcon = L.icon({
      iconUrl: 'image/IconUAVMap.png',
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });
    var jetfighterIcon = L.icon({
      iconUrl: 'image/IconJetFighterMap.png',
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });
    var helicopterIcon = L.icon({
      iconUrl: 'image/IconHelicopterG.jpg',
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });
    var submarineIcon = L.icon({
      iconUrl: 'image/IconSubmarineG.jpg',
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });
    var battleshipIcon = L.icon({
      iconUrl: 'image/IconBattleshipMap.png',
      iconSize: [32, 32],
      iconAnchor: [16, 32],
      popupAnchor: [0, -32]
    });

    // Place icon logic
    let placeMode = null;
    let selectedBtn = null;
  let activeAnimMarker = null; // marker used for path animation
  let isAnimatingPath = false; // prevent concurrent animations
  // RTS selection + move
  let isSelectMode = false;
  const allMarkers = [];
  const selectedUnits = [];
  let suppressNextMapClick = false;
  let unitMoveJobs = [];
  let unitsAnimating = false;
  // Marquee selection state
  let marqueeActive = false;
  let marqueeMoved = false;
  let marqueeStart = null;
  let marqueeRect = null;

    // Attach drag handlers so marker rotates following drag direction
    function attachDirectionalDrag(m) {
      m.on('dragstart', function() {
        m._lastDragPoint = map.latLngToLayerPoint(m.getLatLng());
      });
      m.on('drag', function() {
        if (!m._icon) return;
        const prev = m._lastDragPoint;
        const curr = map.latLngToLayerPoint(m.getLatLng());
        if (prev && (curr.x !== prev.x || curr.y !== prev.y)) {
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          const angleRad = Math.atan2(-dy, dx); // invert Y for screen coords
          const angleDeg = angleRad * 180 / Math.PI;
          const tStr = m._icon.style.transform || '';
          const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
          m._icon.style.transform = `${cleaned} rotate(${angleDeg}deg)`;
          m._icon.style.transformOrigin = '16px 16px';
          m._lastDragPoint = curr;
        }
      });
      m.on('dragend', function() {
        if (!m._icon) return;
        const prev = m._lastDragPoint;
        const curr = map.latLngToLayerPoint(m.getLatLng());
        if (prev && (curr.x !== prev.x || curr.y !== prev.y)) {
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          const angleRad = Math.atan2(-dy, dx);
          const angleDeg = angleRad * 180 / Math.PI;
          const tStr = m._icon.style.transform || '';
          const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
          m._icon.style.transform = `${cleaned} rotate(${angleDeg}deg)`;
          m._icon.style.transformOrigin = '16px 16px';
        }
        m._lastDragPoint = null;
      });
    }

    function setPlaceMode(mode) {
      // Deselect previous button
      if (selectedBtn) {
        if (selectedBtn.id === 'tank-btn') selectedBtn.querySelector('img').src = 'image/IconTankG.jpg';
        if (selectedBtn.id === 'uav-btn') selectedBtn.querySelector('img').src = 'image/IconUAVG.jpg';
        if (selectedBtn.id === 'jetfighter-btn') selectedBtn.querySelector('img').src = 'image/IconJetFighterG.jpg';
        if (selectedBtn.id === 'helicopter-btn') selectedBtn.querySelector('img').src = 'image/IconHelicopterG.jpg';
        if (selectedBtn.id === 'submarine-btn') selectedBtn.querySelector('img').src = 'image/IconSubmarineG.jpg';
        if (selectedBtn.id === 'battleship-btn') selectedBtn.querySelector('img').src = 'image/IconBattleshipG.jpg';
        selectedBtn.classList.remove('selected');
      }
      // Select new button
      placeMode = mode;
      // Turning on place mode cancels select mode
      if (isSelectMode) {
        isSelectMode = false;
        const selBtn = document.getElementById('select-mode-btn');
        if (selBtn) selBtn.classList.remove('selected');
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
      }
      map.getContainer().style.cursor = 'crosshair';
      if (mode === 'tank') {
        selectedBtn = document.getElementById('tank-btn');
        selectedBtn.querySelector('img').src = 'image/IconTankL.jpg';
      } else if (mode === 'uav') {
        selectedBtn = document.getElementById('uav-btn');
        selectedBtn.querySelector('img').src = 'image/IconUAVL.jpg';
      } else if (mode === 'jetfighter') {
        selectedBtn = document.getElementById('jetfighter-btn');
        selectedBtn.querySelector('img').src = 'image/IconJetFighterL.jpg';
      } else if (mode === 'helicopter') {
        selectedBtn = document.getElementById('helicopter-btn');
        selectedBtn.querySelector('img').src = 'image/IconHelicopterL.jpg';
      } else if (mode === 'submarine') {
        selectedBtn = document.getElementById('submarine-btn');
        selectedBtn.querySelector('img').src = 'image/IconSubmarineL.jpg';
      } else if (mode === 'battleship') {
        selectedBtn = document.getElementById('battleship-btn');
        selectedBtn.querySelector('img').src = 'image/IconBattleshipL.jpg';
      }
      selectedBtn.classList.add('selected');
    }

    function clearPlaceMode() {
      if (selectedBtn) {
        if (selectedBtn.id === 'tank-btn') selectedBtn.querySelector('img').src = 'image/IconTankG.jpg';
        if (selectedBtn.id === 'uav-btn') selectedBtn.querySelector('img').src = 'image/IconUAVG.jpg';
        if (selectedBtn.id === 'jetfighter-btn') selectedBtn.querySelector('img').src = 'image/IconJetFighterG.jpg';
        if (selectedBtn.id === 'helicopter-btn') selectedBtn.querySelector('img').src = 'image/IconHelicopterG.jpg';
        if (selectedBtn.id === 'submarine-btn') selectedBtn.querySelector('img').src = 'image/IconSubmarineG.jpg';
        if (selectedBtn.id === 'battleship-btn') selectedBtn.querySelector('img').src = 'image/IconBattleshipG.jpg';
        selectedBtn.classList.remove('selected');
        selectedBtn = null;
      }
      placeMode = null;
      map.getContainer().style.cursor = '';
    }

    document.getElementById('tank-btn').onclick = function() {
      if (placeMode === 'tank') {
        clearPlaceMode();
      } else {
        setPlaceMode('tank');
      }
    };
    document.getElementById('uav-btn').onclick = function() {
      if (placeMode === 'uav') {
        clearPlaceMode();
      } else {
        setPlaceMode('uav');
      }
    };
    document.getElementById('jetfighter-btn').onclick = function() {
      if (placeMode === 'jetfighter') {
        clearPlaceMode();
      } else {
        setPlaceMode('jetfighter');
      }
    };
    document.getElementById('helicopter-btn').onclick = function() {
      if (placeMode === 'helicopter') {
        clearPlaceMode();
      } else {
        setPlaceMode('helicopter');
      }
    };
    document.getElementById('submarine-btn').onclick = function() {
      if (placeMode === 'submarine') {
        clearPlaceMode();
      } else {
        setPlaceMode('submarine');
      }
    };
    document.getElementById('battleship-btn').onclick = function() {
      if (placeMode === 'battleship') {
        clearPlaceMode();
      } else {
        setPlaceMode('battleship');
      }
    };

    map.on('click', function(e) {
      if (!placeMode) return;
      let icon;
      if (placeMode === 'tank') icon = tankIcon;
      if (placeMode === 'uav') icon = uavIcon;
      if (placeMode === 'jetfighter') icon = jetfighterIcon;
      if (placeMode === 'helicopter') icon = helicopterIcon;
      if (placeMode === 'submarine') icon = submarineIcon;
  if (placeMode === 'battleship') icon = battleshipIcon;
      if (icon) {
        const m = L.marker(e.latlng, {icon: icon, draggable: true}).addTo(map);
        m.unitType = placeMode;
        m.isSelected = false;
        allMarkers.push(m);
        // Click to toggle selection when in select mode
        m.on('click', function(ev) {
          if (!isSelectMode) return;
          toggleUnitSelection(m);
          suppressNextMapClick = true;
        });
        // Directional drag for applicable unit types
        if (m.unitType === 'jetfighter' || m.unitType === 'tank' || m.unitType === 'uav' || m.unitType === 'submarine' || m.unitType === 'battleship') {
          attachDirectionalDrag(m);
        }
        // Do NOT clear placeMode here, so user can keep spawning icons
      }
    });

    function toggleUnitSelection(marker) {
      marker.isSelected = !marker.isSelected;
      if (marker._icon) {
        if (marker.isSelected) marker._icon.classList.add('unit-selected');
        else marker._icon.classList.remove('unit-selected');
      }
      const idx = selectedUnits.indexOf(marker);
      if (marker.isSelected && idx === -1) selectedUnits.push(marker);
      if (!marker.isSelected && idx !== -1) selectedUnits.splice(idx, 1);
    }

    // Select mode toggle
    document.getElementById('select-mode-btn').onclick = function() {
      isSelectMode = !isSelectMode;
      this.classList.toggle('selected', isSelectMode);
      if (isSelectMode) {
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleL.jpg';
        // Ensure other modes don't interfere
        clearPlaceMode();
        if (measuring) {
          stopMeasuring();
          const img = document.getElementById('measure-btn-img');
          if (img) img.src = 'image/IconRulerG.jpg';
          const btn = document.getElementById('measure-btn');
          if (btn) btn.style.backgroundColor = '#95a5a6';
        }
        // Exit drawing mode if active
        if (typeof drawingMode !== 'undefined' && drawingMode) {
          stopFreehandDraw();
          const drawImg = document.getElementById('draw-btn-img');
          if (drawImg) drawImg.src = 'image/IconDrawingG.jpg';
          const drawBtn = document.getElementById('draw-btn');
          if (drawBtn) drawBtn.style.backgroundColor = '#95a5a6';
          const palettePanel = document.getElementById('color-palette-panel');
          if (palettePanel) palettePanel.style.display = 'none';
        }
        // Set a clear crosshair cursor to indicate selection
        map.getContainer().style.cursor = 'crosshair';
      } else {
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
        map.getContainer().style.cursor = '';
      }
    };

    // Issue move command on map click in select mode (when not clicking a marker)
    map.on('click', function(e) {
      if (!isSelectMode) return;
      if (suppressNextMapClick) { suppressNextMapClick = false; return; }
      if (selectedUnits.length === 0) return;
      moveSelectedUnitsTo(e.latlng);
    });

    // Marquee selection handlers
    map.on('mousedown', function(e) {
      if (!isSelectMode) return;
      if (e.originalEvent && e.originalEvent.button !== 0) return; // left button only
      marqueeActive = true;
      marqueeMoved = false;
      marqueeStart = e.latlng;
      // Disable map dragging while drawing rectangle
      map.dragging.disable();
      // Create zero-area rectangle
      marqueeRect = L.rectangle([marqueeStart, marqueeStart], {
        color: '#00aaff',
        weight: 2,
        dashArray: '6,4',
        fillColor: '#00aaff',
        fillOpacity: 0.1,
        interactive: false
      }).addTo(map);
    });

    map.on('mousemove', function(e) {
      if (!isSelectMode || !marqueeActive || !marqueeRect) return;
      const p0 = map.latLngToContainerPoint(marqueeStart);
      const p1 = map.latLngToContainerPoint(e.latlng);
      const dx = Math.abs(p1.x - p0.x);
      const dy = Math.abs(p1.y - p0.y);
      if (dx + dy > 5) marqueeMoved = true; // threshold to count as drag
      // Update rectangle bounds
      const bounds = L.latLngBounds(marqueeStart, e.latlng);
      marqueeRect.setBounds(bounds);
    });

    map.on('mouseup', function(e) {
      if (!isSelectMode || !marqueeActive) return;
      // Re-enable map dragging
      map.dragging.enable();
      // If dragged, select units within rectangle
      if (marqueeMoved && marqueeRect) {
        const bounds = marqueeRect.getBounds();
        // Replace current selection with units inside bounds
        // Clear previous selection
        while (selectedUnits.length) {
          const m = selectedUnits.pop();
          m.isSelected = false;
          if (m._icon) m._icon.classList.remove('unit-selected');
        }
        allMarkers.forEach(m => {
          if (bounds.contains(m.getLatLng())) {
            m.isSelected = true;
            if (m._icon) m._icon.classList.add('unit-selected');
            selectedUnits.push(m);
          }
        });
        // Prevent the subsequent click from issuing a move order
        suppressNextMapClick = true;
      }
      // Clean up rectangle
      if (marqueeRect) { map.removeLayer(marqueeRect); marqueeRect = null; }
      marqueeActive = false;
      marqueeMoved = false;
      marqueeStart = null;
    });

    // Geodesic destination from center by distance (m) and bearing (deg)
    function destinationPoint(center, distance, bearingDeg) {
      const R = 6371000; // meters
      const br = bearingDeg * Math.PI / 180;
      const lat1 = center.lat * Math.PI / 180;
      const lon1 = center.lng * Math.PI / 180;
      const dr = distance / R;
      const sinLat1 = Math.sin(lat1), cosLat1 = Math.cos(lat1);
      const sinDr = Math.sin(dr), cosDr = Math.cos(dr);
      const sinLat2 = sinLat1 * cosDr + cosLat1 * sinDr * Math.cos(br);
      const lat2 = Math.asin(sinLat2);
      const y = Math.sin(br) * sinDr * cosLat1;
      const x = cosDr - sinLat1 * sinLat2;
      const lon2 = lon1 + Math.atan2(y, x);
      return L.latLng(lat2 * 180 / Math.PI, ((lon2 * 180 / Math.PI + 540) % 360) - 180);
    }

    function moveSelectedUnitsTo(destLatLng) {
      const DURATION_MS = 3000; // complete move within 3 seconds
      unitMoveJobs = [];
      const now = performance.now();

      const n = selectedUnits.length;
      const targets = [];
      if (n === 1) {
        targets.push(destLatLng);
      } else {
        const baseSpacing = 120; // meters between rings
        let remaining = n;
        let ring = 1;
        while (remaining > 0) {
          const capacity = 6 * ring; // 6, 12, 18, ...
          const onRing = Math.min(remaining, capacity);
          for (let j = 0; j < onRing; j++) {
            const angle = (360 / onRing) * j; // degrees
            targets.push(destinationPoint(destLatLng, baseSpacing * ring, angle));
          }
          remaining -= onRing;
          ring++;
        }
      }

      // Assign targets in order of selection
      selectedUnits.forEach((m, i) => {
        const target = targets[Math.min(i, targets.length - 1)];
        const from = m.getLatLng();
        const dist = map.distance(from, target);
        const duration = DURATION_MS; // constant duration for all
        unitMoveJobs.push({ marker: m, from, to: target, dist, start: now, duration });
      });
      if (!unitsAnimating) {
        unitsAnimLoop();
      }
    }

    function unitsAnimLoop() {
      unitsAnimating = true;
      const now = performance.now();
      let remaining = 0;
      unitMoveJobs.forEach(job => {
        const t = job.duration > 0 ? Math.min(1, (now - job.start) / job.duration) : 1;
        const lat = job.from.lat + (job.to.lat - job.from.lat) * t;
        const lng = job.from.lng + (job.to.lng - job.from.lng) * t;
        const a = job.from; const b = job.to;
        job.marker.setLatLng([lat, lng]);
        if (job.marker.unitType === 'jetfighter' && job.marker._icon) {
          const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
          const angleDeg = angleRad * 180 / Math.PI;
          const tStr = job.marker._icon.style.transform || '';
          const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
          job.marker._icon.style.transform = `${cleaned} rotate(${angleDeg}deg)`;
          job.marker._icon.style.transformOrigin = '16px 16px';
        }
        if (t < 1) remaining++;
      });
      if (remaining > 0) {
        requestAnimationFrame(unitsAnimLoop);
      } else {
        unitsAnimating = false;
      }
    }

    // Animate the selected icon type along the last drawn path
    function animateAlongPath() {
      if (isAnimatingPath) return; // already running
      if (!placeMode) {
        alert('Select an icon (tank/uav/jetfighter/helicopter/submarine) first.');
        return;
      }
      if (!lastDrawnPath) {
        alert('Draw a path first using the pen tool.');
        return;
      }
      const pathLatLngs = lastDrawnPath.getLatLngs();
      if (!pathLatLngs || pathLatLngs.length < 2) {
        alert('Path is too short to animate.');
        return;
      }
      let icon = null;
      if (placeMode === 'tank') icon = tankIcon;
      if (placeMode === 'uav') icon = uavIcon;
      if (placeMode === 'jetfighter') icon = jetfighterIcon;
      if (placeMode === 'helicopter') icon = helicopterIcon;
      if (placeMode === 'submarine') icon = submarineIcon;
      if (!icon) return;

      if (activeAnimMarker) {
        map.removeLayer(activeAnimMarker);
        activeAnimMarker = null;
      }

      activeAnimMarker = L.marker(pathLatLngs[0], {icon: icon, draggable: false}).addTo(map);

      // Build segment distances and total length
      const segDist = [];
      let total = 0;
      for (let i = 1; i < pathLatLngs.length; i++) {
        const d = map.distance(pathLatLngs[i-1], pathLatLngs[i]);
        segDist.push(d);
        total += d;
      }
      if (total === 0) return;

  const speed = 1500; // meters per second (one-way, no loop)
      const duration = total / speed * 1000; // ms
      const startTime = performance.now();
  isAnimatingPath = true;
  const animateBtn = document.getElementById('animate-path-btn');
  if (animateBtn) animateBtn.disabled = true;

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function step(now) {
        let elapsed = now - startTime;
        if (elapsed < 0) elapsed = 0;
        const t = Math.min(1, elapsed / duration);
        const targetDist = t * total;

        // Find segment for targetDist
        let acc = 0;
        let segIndex = 0;
        while (segIndex < segDist.length && acc + segDist[segIndex] < targetDist) {
          acc += segDist[segIndex];
          segIndex++;
        }
        if (segIndex >= segDist.length) {
          activeAnimMarker.setLatLng(pathLatLngs[pathLatLngs.length - 1]);
          isAnimatingPath = false;
          if (animateBtn) animateBtn.disabled = false;
          return; // end (one go only)
        }
        const segLen = segDist[segIndex];
        const segT = segLen > 0 ? (targetDist - acc) / segLen : 0;
        const a = pathLatLngs[segIndex];
        const b = pathLatLngs[segIndex + 1];
        const lat = lerp(a.lat, b.lat, segT);
        const lng = lerp(a.lng, b.lng, segT);
        const pos = L.latLng(lat, lng);
        activeAnimMarker.setLatLng(pos);

        // Optional: rotate for jetfighter to face movement direction
        if (placeMode === 'jetfighter' && activeAnimMarker._icon) {
          const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
          const angleDeg = angleRad * 180 / Math.PI;
          const tStr = activeAnimMarker._icon.style.transform || '';
          const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
          activeAnimMarker._icon.style.transform = `${cleaned} rotate(${angleDeg}deg)`;
          activeAnimMarker._icon.style.transformOrigin = '16px 16px';
        }

        if (t < 1) requestAnimationFrame(step);
        else {
          isAnimatingPath = false;
          if (animateBtn) animateBtn.disabled = false;
        }
      }
      requestAnimationFrame(step);
    }

    document.getElementById('animate-path-btn').onclick = animateAlongPath;

    // Memorize and go to location logic
    // Load memorized locations from localStorage
    function loadMemorized() {
      try {
        const saved = localStorage.getItem('memorizedLocations');
        if (saved) {
          const arr = JSON.parse(saved);
          // Convert center back to LatLng objects
          return arr.map(loc => {
            if (!loc) return null;
            return {
              ...loc,
              center: L.latLng(loc.center.lat, loc.center.lng)
            };
          });
        }
      } catch (e) {}
      return [null, null, null, null, null];
    }

    function saveMemorized() {
      localStorage.setItem('memorizedLocations', JSON.stringify(memorized));
    }

    var memorized = loadMemorized();
    var currentMode = 'memorize'; // Default to memorize mode
    
    // Function to get elevation from coordinates
    async function getElevation(lat, lng) {
      try {
        // Using Open-Elevation API (free service)
        const response = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`);
        const data = await response.json();
        if (data.results && data.results.length > 0) {
          return data.results[0].elevation;
        }
        return null;
      } catch (error) {
        console.log('Elevation service unavailable, using map zoom as approximation');
        // Fallback: approximate elevation based on zoom level (very rough estimate)
        const zoom = map.getZoom();
        return Math.max(0, (20 - zoom) * 100); // Rough approximation
      }
    }
    
    async function memorize(idx) {
      const center = map.getCenter();
      const zoom = map.getZoom();
      
      // Show loading message
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = 'Getting elevation data...';
      loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:10px;border-radius:5px;z-index:9999;';
      document.body.appendChild(loadingMsg);
      
      try {
        const elevation = await getElevation(center.lat, center.lng);
        memorized[idx] = {
          center: center,
          zoom: zoom,
          elevation: elevation,
          timestamp: new Date().toLocaleString()
        };
        saveMemorized();
        document.body.removeChild(loadingMsg);
        const elevationText = elevation !== null ? `${Math.round(elevation)}m` : 'Unknown';
        alert(`Location ${idx+1} memorized!\nCoordinates: ${center.lat.toFixed(6)}, ${center.lng.toFixed(6)}\nElevation: ${elevationText}\nZoom: ${zoom}`);
        updateLocationButtons(); // Update button appearance
      } catch (error) {
        document.body.removeChild(loadingMsg);
        alert('Error getting elevation data. Location saved without elevation.');
        memorized[idx] = {
          center: center,
          zoom: zoom,
          elevation: null,
          timestamp: new Date().toLocaleString()
        };
        saveMemorized();
        updateLocationButtons();
      }
    }
    
    function goTo(idx) {
      if (!memorized[idx]) {
        alert('No location memorized for '+(idx+1));
        return;
      }
      const target = memorized[idx];
      const elevationText = target.elevation !== null ? `${Math.round(target.elevation)}m` : 'Unknown';
      alert(`Going to Location ${idx+1}\nCoordinates: ${target.center.lat.toFixed(6)}, ${target.center.lng.toFixed(6)}\nElevation: ${elevationText}\nSaved: ${target.timestamp}`);

      // Preload tiles for smoother fly-in
      preloadTiles(target.center, target.zoom).then(() => {
        map.setView(target.center, target.zoom, {animate: true, duration: 2});
      });
    }

    // Preload tiles for a given center and zoom
    function preloadTiles(center, zoom) {
      return new Promise(resolve => {
        // Calculate tile coordinates for the center
        var tileSize = 256;
        var crs = map.options.crs;
        var tileCoords = crs.project(center);
        var scale = crs.scale(zoom);
        var tileX = Math.floor(tileCoords.x * scale / tileSize);
        var tileY = Math.floor(tileCoords.y * scale / tileSize);

        // Preload a 3x3 grid of tiles around the center
        var promises = [];
        for (var dx = -1; dx <= 1; dx++) {
          for (var dy = -1; dy <= 1; dy++) {
            var x = tileX + dx;
            var y = tileY + dy;
            var url = map._layers[Object.keys(map._layers)[0]]._url
              .replace('{z}', zoom)
              .replace('{x}', x)
              .replace('{y}', y);
            promises.push(fetch(url).catch(()=>{}));
          }
        }
        Promise.all(promises).then(() => setTimeout(resolve, 200)); // Wait a bit for browser cache
      });
    }
    
    function showAllLocations() {
      let locationList = 'Memorized Locations:\n\n';
      let hasLocations = false;
      
      for (let i = 0; i < 5; i++) {
        if (memorized[i]) {
          hasLocations = true;
          const loc = memorized[i];
          const elevationText = loc.elevation !== null ? `${Math.round(loc.elevation)}m` : 'Unknown';
          locationList += `Map ${i+1}:\n`;
          locationList += `  Coordinates: ${loc.center.lat.toFixed(6)}, ${loc.center.lng.toFixed(6)}\n`;
          locationList += `  Elevation: ${elevationText}\n`;
          locationList += `  Zoom Level: ${loc.zoom}\n`;
          locationList += `  Saved: ${loc.timestamp}\n\n`;
        }
      }
      
      if (!hasLocations) {
        alert('No locations have been memorized yet.');
      } else {
        alert(locationList);
      }
    }
    
    function updateLocationButtons() {
      for (let i = 1; i <= 5; i++) {
        const btn = document.getElementById('location-' + i);
        const img = document.getElementById('location-img-' + i);
        const isMemorized = memorized[i-1] !== null;
        if (currentMode === 'memorize') {
          img.src = 'image/IconMapR.jpg';
        } else {
          img.src = isMemorized ? 'image/IconMapL.jpg' : 'image/IconMapG.jpg';
        }
        btn.className = 'location-btn';
        btn.style.opacity = currentMode === 'go' && !isMemorized ? '0.5' : '1';
      }
      saveMemorized(); // Save state on every update
    }
    
    function handleLocationClick(index) {
      if (currentMode === 'memorize') {
        memorize(index);
      } else {
        goTo(index);
      }
    }
    
    // Set up location button event listeners
    for (let i = 1; i <= 5; i++) {
      document.getElementById('location-' + i).onclick = function() {
        handleLocationClick(i - 1);
      };
    }
    
    // Mode switch icon logic
    function setMode(mode) {
      currentMode = mode;
      updateLocationButtons();
      // Update icons
      if (mode === 'memorize') {
        document.getElementById('mode-memorize').classList.add('selected');
        document.getElementById('mode-go').classList.remove('selected');
        document.getElementById('mode-memorize-img').src = 'image/IconSaveL.jpg';
        document.getElementById('mode-go-img').src = 'image/IconGotoMapG.jpg';
      } else {
        document.getElementById('mode-go').classList.add('selected');
        document.getElementById('mode-memorize').classList.remove('selected');
        document.getElementById('mode-memorize-img').src = 'image/IconSaveG.jpg';
        document.getElementById('mode-go-img').src = 'image/IconGotoMapL.jpg';
      }
    }

    document.getElementById('mode-memorize').onclick = function() { setMode('memorize'); };
    document.getElementById('mode-go').onclick = function() { setMode('go'); };

    // Measuring tool variables
    var measuring = false;
    var measurePoints = [];
    var measureLine = null;
    var measureMarkers = [];
    var measureTooltip = null;

    function startMeasuring() {
      measuring = true;
      measurePoints = [];
      if (measureLine) { map.removeLayer(measureLine); measureLine = null; }
      measureMarkers.forEach(m => map.removeLayer(m));
      measureMarkers = [];
      if (measureTooltip) { map.removeLayer(measureTooltip); measureTooltip = null; }
      map.getContainer().style.cursor = 'crosshair';
    }

    function stopMeasuring() {
      measuring = false;
      map.getContainer().style.cursor = '';
    }

    function updateMeasure() {
      if (measureLine) { map.removeLayer(measureLine); measureLine = null; }
      measureMarkers.forEach(m => map.removeLayer(m));
      measureMarkers = [];
      if (measurePoints.length > 1) {
        measureLine = L.polyline(measurePoints, {color: 'orange', weight: 4, dashArray: '6,6'}).addTo(map);
      }
      measurePoints.forEach((pt, i) => {
        var marker = L.circleMarker(pt, {radius: 6, color: 'orange', fillColor: 'white', fillOpacity: 1, weight: 2}).addTo(map);
        measureMarkers.push(marker);
      });
      // Tooltip for total distance
      if (measureTooltip) { map.removeLayer(measureTooltip); measureTooltip = null; }
      if (measurePoints.length > 1) {
        var dist = 0;
        for (var i=1; i<measurePoints.length; i++) {
          dist += map.distance(measurePoints[i-1], measurePoints[i]);
        }
        var last = measurePoints[measurePoints.length-1];
        var distText = dist >= 1000 ? (dist/1000).toFixed(2) + ' km' : dist.toFixed(1) + ' m';
        measureTooltip = L.popup({closeButton:false, autoClose:false})
          .setLatLng(last)
          .setContent('<b>Total: ' + distText + '</b>')
          .addTo(map);
      }
    }

    document.getElementById('measure-btn').onclick = function() {
      var img = document.getElementById('measure-btn-img');
      if (measuring) {
        stopMeasuring();
        img.src = 'image/IconRulerG.jpg';
        img.alt = 'Measure Distance';
        this.style.backgroundColor = '#95a5a6';
        // Do NOT clear measurement visuals here
      } else {
        startMeasuring();
        img.src = 'image/IconRulerL.jpg';
        img.alt = 'Stop Measuring';
        this.style.backgroundColor = '#e67e22';
      }
    };

    map.on('click', function(e) {
      if (measuring) {
        measurePoints.push(e.latlng);
        updateMeasure();
      }
    });

    map.on('dblclick', function(e) {
      if (measuring) {
        stopMeasuring();
        document.getElementById('measure-btn').textContent = 'Measure Distance';
        document.getElementById('measure-btn').style.backgroundColor = '#95a5a6';
        // Do NOT clear measurement visuals here
      }
    });

    // Initialize button appearance
    updateLocationButtons();

    // Show/hide palette when pen is activated
    document.getElementById('draw-btn').addEventListener('click', function() {
      var panel = document.getElementById('color-palette-panel');
      panel.style.display = drawingMode ? 'block' : 'none';
    });

    // Pen color selection logic
    var penColor = "#ff0000"; // Default to red
    document.querySelectorAll('.palette-color-btn').forEach(function(btn) {
      btn.onclick = function() {
        penColor = btn.getAttribute('data-color');
        document.querySelectorAll('.palette-color-btn').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid #333';
      };
    });

    // penColor is applied in mouse/touch drawing handlers above
  </script>
</body>
</html>