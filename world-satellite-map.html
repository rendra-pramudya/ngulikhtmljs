<!DOCTYPE html>
<html lang="en">
<head>
  <style>
  </style>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>World Satellite Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />
  <style>
    #map {
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
    }
    body {
      margin: 0;
      padding: 0;
    }
    .control-panel {
      position: absolute;
      z-index: 1000;
      right: 400px;
      top: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      
      margin: 0;
    }
    .map-btn-img {
      position: relative;
      display: inline-block;
      width: 32px;
      height: 32px;
    }
    .map-btn-img img {
      width: 32px;
      height: 32px;
      display: block;
    }
    .map-btn-num {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.3em;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 4px #000, 0 0 2px #333;
      pointer-events: none;
    }
    .location-btn.memorize-mode {
      background-color: #e74c3c;
      color: white;
    }
    .location-btn.memorize-mode:hover {
      background-color: #c0392b;
    }
    .location-btn.go-mode {
      background-color: #3498db;
      color: white;
    }
    .location-btn.go-mode:hover {
      background-color: #2980b9;
    }
    .other-buttons {
      display: flex;
      flex-direction: column;
      gap: 0px;
      align-items: flex-start;
      margin-top: 10px;
    }
    .other-buttons button {
      display: flex;
      align-items: center;
      width: 48px;
      height: 48px;
      padding: 0;
      border: none;
      border-radius: 0px;
      background: none;
      cursor: pointer;
    }
    .other-buttons button:hover {
      background-color: #7f8c8d;
    }
    #drawing-panel {
      top: 80px;
      right: 70px;
      width: 32px;
    }
    #mode-panel {
      top: 10px;
      right: 10px;
      width: 92px;
    }
      #map-panel {
        top: 80px;
        right: 10px;
        width: 50px; /* widened panel to fit wider buttons */
        padding: 0; /* ensure content fits exact width */
      }
      /* Make sure location buttons fit exactly inside the 32px panel */
      #map-panel .location-buttons {
        display: block;
        flex-direction: column;
        align-items: center;
        gap: 40px;
        margin: 0;
        padding: 0;
        align-items: center;
        justify-content: center;
        
      }
      #map-panel .location-btn {
        width: 50px;  /* wider click target */
        height: 50px; /* slightly taller for symmetry */
        padding: 0;
        border: none;
        background: none;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #map-panel .map-btn-img,
      #map-panel .map-btn-img img {
        width: 32px;  /* keep the icon at 32px */
        height: 32px;
        display: block;
      }
    #action-mode-panel {
      position: absolute;
      z-index: 1000;
      right: 200px;
      top: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 0;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-family: Arial, sans-serif;
    }
    .action-mode-switch {
      display: flex;
      flex-direction: column;
      gap: 0px;
      align-items: flex-start;
    }
    .action-mode-switch button {
      width: 90px;
      height: 32px;
      font-size: 1em;
      cursor: pointer;
      border: none;
      background: #eee;
      margin-bottom: 4px;
    }
    .action-mode-switch button.selected {
      background: #3498db;
      color: white;
    }
    .color-palette-buttons {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: center;
    }
    .palette-color-btn {
      width: 32px;
      height: 32px;
      border: none;
      cursor: pointer;
      position: relative;
    }
    .palette-color-btn:hover {
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }
    .palette-color-btn.selected {
      border: 2px solid #333;
    }
    /* Selection highlight for units */
    .leaflet-marker-icon.unit-selected {
      filter: drop-shadow(0 0 6px yellow) brightness(1.15);
    }
    /* Heading tooltip styling */
    .heading-tooltip .leaflet-tooltip-content { padding: 2px 4px; }
  .heading-tip { display: inline-flex; align-items: center; gap: 0; font-family: Arial, sans-serif; font-size: 11px; color: #fff; text-shadow: 0 1px 1px rgba(0,0,0,0.6); }
    .leaflet-tooltip.heading-tooltip { background: rgba(0,0,0,0.65); border: 0; border-radius: 3px; box-shadow: 0 1px 4px rgba(0,0,0,0.3); }
  .leaflet-tooltip.heading-tooltip.leaflet-tooltip-top:before,
  .leaflet-tooltip.heading-tooltip.leaflet-tooltip-bottom:before,
  .leaflet-tooltip.heading-tooltip.leaflet-tooltip-left:before,
  .leaflet-tooltip.heading-tooltip.leaflet-tooltip-right:before { display: none; }
  /* Measure popup styling: no pointer tip and no rounded corners */
  .leaflet-popup.measure-popup .leaflet-popup-tip-container { display: none; }
  .leaflet-popup.measure-popup .leaflet-popup-content-wrapper { border-radius: 0; background: rgba(0,0,0,0.9); color: #fff; }
  .leaflet-popup.measure-popup .leaflet-popup-content { color: #fff; margin: 6px 8px; }
  .leaflet-popup.measure-popup { border-radius: 0; }
  </style>
</head>
<body>
  
  <div class="control-panel" id="drawing-panel">
    <div class="location-buttons">
      <button id="draw-btn" style="padding:0;border:none;background:none;">
        <img id="draw-btn-img" src="image/IconDrawingG.jpg" alt="Freehand Draw" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="clear-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconClearG.jpg" alt="Clear Drawings" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="undo-btn" style="padding:0;border:none;background:none;">
        <img id="undo-btn-img" src="image/IconUndoG.jpg" alt="Undo" style="width:32px;height:32px;vertical-align:middle;opacity:0.5;">
      </button>
      <button id="move-btn" style="padding:0;border:none;background:none;">
        <img id="move-btn-img" src="image/IconMoveG.jpg" alt="Move" style="width:32px;height:32px;vertical-align:middle;">
      </button>
    </div>
  </div>

  <div class="control-panel" id="tools-panel" style="top: 235px; right: 70px; width: 32px;">
    <div class="location-buttons">
      <button id="measure-btn" style="padding:0;border:none;background:none;">
        <img id="measure-btn-img" src="image/IconRulerG.jpg" alt="Measure Distance" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="tank-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconTankG.jpg" alt="Tank Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="uav-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconUAVG.jpg" alt="UAV Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="jetfighter-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconJetFighterG.jpg" alt="JetFighter Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="helicopter-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconHelicopterG.jpg" alt="Helicopter Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="submarine-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconSubmarineG.jpg" alt="Submarine Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="battleship-btn" style="padding:0;border:none;background:none;">
        <img src="image/IconBattleshipG.jpg" alt="Battleship Icon" style="width:32px;height:32px;vertical-align:middle;">
      </button>
      <button id="select-mode-btn" title="Select units" style="padding:0;border:none;background:none;width:32px;height:32px;line-height:32px;text-align:center;">
        <img id="select-mode-btn-img" src="image/IconSelectRectangleG.jpg" alt="Select Units" style="width:32px;height:32px;vertical-align:middle;">
      </button>
  
    </div>
  </div>
  <div class="control-panel" id="map-panel">
    <div class="location-buttons" >
      <button class="location-btn" id="location-1"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-1" style="padding:0;border:none;width:32px;height:32px;"><span class="map-btn-num" id="location-num-1">1</span></span></button>
      <button class="location-btn" id="location-2"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-2" style="padding:0;width:32px;height:32px;"><span class="map-btn-num" id="location-num-2">2</span></span></button>
      <button class="location-btn" id="location-3"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-3" style="padding:0;width:32px;height:32px;"><span class="map-btn-num" id="location-num-3">3</span></span></button>
      <button class="location-btn" id="location-4"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-4" style="padding:0;width:32px;height:32px;"><span class="map-btn-num" id="location-num-4">4</span></span></button>
      <button class="location-btn" id="location-5"><span class="map-btn-img"><img src="image/IconMapG.jpg" id="location-img-5" style="padding:0;width:32px;height:32px;"><span class="map-btn-num" id="location-num-5">5</span></span></button>
    </div>
  </div>
  <!-- Bottom-left toast container -->
  <div id="toast-container" style="position:fixed;left:10px;bottom:10px;z-index:9999;display:flex;flex-direction:column;gap:6px;"></div>
  <div class="control-panel" id="mode-panel">
    <div class="mode-switch">
      <button id="mode-memorize" style="padding:0;border:none;background:none;outline:none;">
        <img id="mode-memorize-img" src="image/IconSaveL.jpg" alt="Memorize Mode" style="width:40px;height:40px;vertical-align:middle;">
      </button>
      <button id="mode-go" style="padding:0;border:none;background:none;outline:none;">
        <img id="mode-go-img" src="image/IconGotoMapG.jpg" alt="Go Mode" style="width:40px;height:40px;vertical-align:middle;">
      </button>
    </div>
  </div>
  <div class="control-panel" id="color-palette-panel" style="top: 80px; right: 130px; width: 40px; display: none;">
    <div class="color-palette-buttons">
      <button class="palette-color-btn" data-color="#ff0000" title="Red" style="background:#ff0000;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#00ff00" title="Green" style="background:#00ff00;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#0000ff" title="Blue" style="background:#0000ff;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#000000" title="Black" style="background:#000000;width:32px;height:32px;border:none;margin-bottom:4px;"></button>
      <button class="palette-color-btn" data-color="#ffffff" title="White" style="background:#ffffff;width:32px;height:32px;border:1px solid #ccc;margin-bottom:4px;"></button>
    </div>
  </div>
  <!-- action-mode-panel removed as requested -->
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
  <script>
    function showToast(message, timeoutMs = 2000) {
      const c = document.getElementById('toast-container');
      if (!c) return;
      const el = document.createElement('div');
      el.textContent = message;
      el.style.cssText = 'background:rgba(0,0,0,0.85);color:#fff;padding:6px 10px;border-radius:3px;font-family:Arial, sans-serif;font-size:12px;box-shadow:0 2px 6px rgba(0,0,0,0.3);max-width:280px;';
      c.appendChild(el);
      setTimeout(() => { try { c.removeChild(el); } catch(_){} }, timeoutMs);
    }
    
    // Map setup
    var map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 19,
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    }).addTo(map);

    // Simple Move toggle under Undo (icon-only state)
    let moveActive = false;
    const moveBtn = document.getElementById('move-btn');
    const moveImg = document.getElementById('move-btn-img');
    function deactivateMove() {
      moveActive = false;
      if (moveImg) moveImg.src = 'image/IconMoveG.jpg';
    }

    // Helper: determine if any tool (tools panel or drawing) is active
    function isAnyToolActive() {
      return !!placeMode || !!animDrawActive || !!isSelectMode || !!measuring || !!drawingMode;
    }
    // Helper: Only allow map movement when Move is active; otherwise lock interactions
    function updateMapLockByTools() {
      const shouldUnlock = !!moveActive;
      try { applyMapLock(!shouldUnlock); } catch(_) {}
    }

    // Radio group helpers
    function getActiveRadioTool() {
      if (drawingMode) return 'draw';
      if (moveActive) return 'move';
      if (measuring) return 'measure';
      if (isSelectMode) return 'select';
      if (animDrawActive) return 'anim:' + (animDrawUnitType || '');
      return null;
    }

    function deactivateAllRadioTools() {
      // Stop drawing
      if (drawingMode) {
        try { stopFreehandDraw(); } catch(_) {}
        const drawImg = document.getElementById('draw-btn-img');
        if (drawImg) { drawImg.src = 'image/IconDrawingG.jpg'; drawImg.alt = 'Freehand Draw'; }
        const drawBtn = document.getElementById('draw-btn');
        if (drawBtn) drawBtn.style.backgroundColor = '#95a5a6';
        const palettePanel = document.getElementById('color-palette-panel');
        if (palettePanel) palettePanel.style.display = 'none';
      }
      // Stop measuring
      if (measuring) {
        try { stopMeasuring(); } catch(_) {}
        const mImg = document.getElementById('measure-btn-img');
        if (mImg) mImg.src = 'image/IconRulerG.jpg';
        const mBtn = document.getElementById('measure-btn');
        if (mBtn) mBtn.style.backgroundColor = '#95a5a6';
      }
      // Clear select
      if (isSelectMode) {
        isSelectMode = false;
        const selBtn = document.getElementById('select-mode-btn');
        if (selBtn) selBtn.classList.remove('selected');
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
        try { map.getContainer().style.cursor = ''; } catch(_) {}
      }
      // Clear anim-draw
      if (animDrawActive) {
        try { clearAnimDrawMode(); } catch(_) {}
      } else {
        // Ensure unit button visuals are reset if needed
        try { if (typeof updateUnitButtonsVisual === 'function') updateUnitButtonsVisual(null); } catch(_) {}
      }
      // Clear placement (if any legacy placement used)
      try { clearPlaceMode(); } catch(_) {}
      // Move off
      deactivateMove();
      try { updateMapLockByTools(); } catch(_) {}
    }

    function setRadioTool(tool) {
      const current = getActiveRadioTool();
      if (current === tool) {
        // Toggle off if already active
        deactivateAllRadioTools();
        return;
      }
      // Switch: deactivate others first
      deactivateAllRadioTools();
      switch (tool) {
        case 'draw': {
          startFreehandDraw();
          const img = document.getElementById('draw-btn-img');
          if (img) { img.src = 'image/IconDrawingL.jpg'; img.alt = 'Stop Drawing'; }
          const btn = document.getElementById('draw-btn');
          if (btn) btn.style.backgroundColor = '#e74c3c';
          const palettePanel = document.getElementById('color-palette-panel');
          if (palettePanel) palettePanel.style.display = 'block';
          break;
        }
        case 'move': {
          moveActive = true;
          if (moveImg) moveImg.src = 'image/IconMoveL.jpg';
          break;
        }
        case 'measure': {
          startMeasuring();
          const mImg = document.getElementById('measure-btn-img');
          if (mImg) { mImg.src = 'image/IconRulerL.jpg'; mImg.alt = 'Stop Measuring'; }
          const mBtn = document.getElementById('measure-btn');
          if (mBtn) mBtn.style.backgroundColor = '#e67e22';
          break;
        }
        case 'select': {
          isSelectMode = true;
          const selBtn = document.getElementById('select-mode-btn');
          if (selBtn) selBtn.classList.add('selected');
          const selImg = document.getElementById('select-mode-btn-img');
          if (selImg) selImg.src = 'image/IconSelectRectangleL.jpg';
          try { map.getContainer().style.cursor = 'crosshair'; } catch(_) {}
          break;
        }
        case 'anim:tank':
        case 'anim:uav':
        case 'anim:jetfighter':
        case 'anim:helicopter':
        case 'anim:submarine':
        case 'anim:battleship': {
          const t = tool.split(':')[1];
          setAnimDrawMode(t);
          break;
        }
      }
      try { updateMapLockByTools(); } catch(_) {}
    }
    if (moveBtn && moveImg) {
      moveBtn.addEventListener('click', function() { setRadioTool('move'); });
    }
    // Initial policy: lock map until Move is turned on
    try { updateMapLockByTools(); } catch(_) {}

    // Remove Leaflet attribution control
    map.attributionControl.remove();

    // Freehand drawing setup
    var drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);
  var lastDrawnPath = null; // stores the most recent freehand polyline
    var drawHistory = []; // stack of Leaflet layers added by freehand
    // Path-follow animation state
    let pathMoveJobs = [];
    let pathAnimating = false;
    

    // Country borders overlay (global)
    // Use public Natural Earth countries GeoJSON via DataHub
    try {
      map.createPane('bordersPane');
      map.getPane('bordersPane').style.zIndex = 430; // above tiles, below markers
      fetch('https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson')
        .then(r => r.json())
        .then(geo => {
          L.geoJSON(geo, {
            pane: 'bordersPane',
            interactive: false,
            smoothFactor: 1,
            style: function() {
              return {
                color: '#ffffff',
                weight: 1,
                opacity: 0.7,
                fillOpacity: 0
              };
            }
          }).addTo(map);
        })
        .catch(e => console.warn('Borders load failed:', e));
    } catch (e) { console.warn('Borders setup error:', e); }
    
    // Freehand drawing variables
    var isDrawing = false;
    var currentPath = [];
    var drawingMode = false;
  // Revert to separate mouse/touch handlers (no pointer unification)

    function finalizeFreehandPath() {
      if (currentPath.length > 1) {
        // Remove temporary line
        map.eachLayer(function(layer) {
          if (layer.options && layer.options.temp) {
            map.removeLayer(layer);
          }
        });
        // Add final polyline to drawn items
        var finalLine = L.polyline(currentPath, {
          color: penColor,
          weight: 3,
          opacity: 1
        });
        drawnItems.addLayer(finalLine);
        lastDrawnPath = finalLine;
        drawHistory.push(finalLine);
        var undoImgPtr = document.getElementById('undo-btn-img');
        if (undoImgPtr) undoImgPtr.style.opacity = '1';
        if (selectedUnits.length > 0) {
          const pathLatLngs = lastDrawnPath.getLatLngs();
          startPathMoveForMarkers(selectedUnits.slice(), pathLatLngs, 1500);
        }
      }
      currentPath = [];
    }
    
    // Freehand drawing functions
    function startFreehandDraw() {
      drawingMode = true;
      // Exit select mode to avoid conflicts with marquee handlers
      if (typeof isSelectMode !== 'undefined' && isSelectMode) {
        isSelectMode = false;
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
      }
      map.getContainer().style.cursor = 'crosshair';
      map.dragging.disable();
      map.touchZoom && map.touchZoom.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();
      map.boxZoom.disable();
      map.keyboard.disable();
      if (map.tap) map.tap.disable();
  // Prevent browser-native touch gestures while drawing
  if (map && map._container) { try { map._container.style.touchAction = 'none'; } catch(_){} }
      // Show color palette when drawing starts
      const palettePanelStart = document.getElementById('color-palette-panel');
      if (palettePanelStart) palettePanelStart.style.display = 'block';
      try { updateMapLockByTools(); } catch(_) {}
    }
    
    function stopFreehandDraw() {
      drawingMode = false;
      isDrawing = false;
      currentPath = [];
      map.getContainer().style.cursor = '';
      map.dragging.enable();
      map.touchZoom && map.touchZoom.enable();
      map.doubleClickZoom.enable();
      map.scrollWheelZoom.enable();
      map.boxZoom.enable();
      map.keyboard.enable();
      if (map.tap) map.tap.enable();
      // Hide color palette whenever drawing stops (icon turns G)
      const palettePanelStop = document.getElementById('color-palette-panel');
      if (palettePanelStop) palettePanelStop.style.display = 'none';
    }
    
    function clearAllDrawings() {
      drawnItems.clearLayers();
      drawHistory = [];
      lastDrawnPath = null;
      var undoImg = document.getElementById('undo-btn-img');
      if (undoImg) undoImg.style.opacity = '0.5';
      if (measureLine) { try { map.removeLayer(measureLine); } catch(_) {} measureLine = null; }
      measureMarkers.forEach(m => { try { map.removeLayer(m); } catch(_) {} });
      measureMarkers = [];
      if (measureTooltip) { try { map.removeLayer(measureTooltip); } catch(_) {} measureTooltip = null; }
      measurePoints = [];
      // Also clear all unit icons on the map
      while (selectedUnits.length) {
        const m = selectedUnits.pop();
        m.isSelected = false;
        if (m._icon) m._icon.classList.remove('unit-selected');
      }
      allMarkers.forEach(m => { try { map.removeLayer(m); } catch(_){} });
      allMarkers.length = 0;
      // Stop any ongoing move/path jobs
      unitMoveJobs = [];
      unitsAnimating = false;
      pathMoveJobs = [];
      pathAnimating = false;
    }

    // Mouse event handlers for freehand drawing
    map.on('mousedown', function(e) {
      if (!drawingMode) return;
      if (e && e.originalEvent) { try { e.originalEvent.preventDefault(); } catch(_){} }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      isDrawing = true;
      currentPath = [e.latlng];
    });
    
    map.on('mousemove', function(e) {
      if (!drawingMode || !isDrawing) return;
      if (e && e.originalEvent) { try { e.originalEvent.preventDefault(); } catch(_){} }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      currentPath.push(e.latlng);

      // Remove previous temporary line
      map.eachLayer(function(layer) {
        if (layer.options && layer.options.temp) {
          map.removeLayer(layer);
        }
      });

      // Add new temporary line
      L.polyline(currentPath, {
        color: penColor,
        weight: 3,
        opacity: 0.7,
        temp: true
      }).addTo(map);
    });
    
    map.on('mouseup', function(e) {
      if (!drawingMode || !isDrawing) return;
      if (e && e.originalEvent) { try { e.originalEvent.preventDefault(); } catch(_){} }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      isDrawing = false;

      if (currentPath.length > 1) {
        // Remove temporary line
        map.eachLayer(function(layer) {
          if (layer.options && layer.options.temp) {
            map.removeLayer(layer);
          }
        });

        // Add final polyline to drawn items
        var finalLine = L.polyline(currentPath, {
          color: penColor,
          weight: 3,
          opacity: 1
        });
        drawnItems.addLayer(finalLine);
        lastDrawnPath = finalLine; // remember this path
        drawHistory.push(finalLine);
        var undoImg1 = document.getElementById('undo-btn-img');
        if (undoImg1) undoImg1.style.opacity = '1';
        // If units are selected, have them follow the drawn path
        if (selectedUnits.length > 0) {
          const pathLatLngs = lastDrawnPath.getLatLngs();
          startPathMoveForMarkers(selectedUnits.slice(), pathLatLngs, 1500);
        }
      }

      currentPath = [];
    });
    
    // Touch event handlers for mobile devices
    map.on('touchstart', function(e) {
      if (!drawingMode) return;
      if (!e.originalEvent) return;
      try { e.originalEvent.preventDefault(); } catch(_){}
      const touch = e.originalEvent.touches && e.originalEvent.touches[0] ? e.originalEvent.touches[0] : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      isDrawing = true;
      currentPath = [latlng];
    });
    
    map.on('touchmove', function(e) {
      if (!drawingMode || !isDrawing) return;
      if (!e.originalEvent) return;
      try { e.originalEvent.preventDefault(); } catch(_){}
      const touch = e.originalEvent.touches && e.originalEvent.touches[0] ? e.originalEvent.touches[0] : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      currentPath.push(latlng);
      
      if (currentPath.length > 1) {
        map.eachLayer(function(layer) {
          if (layer.options && layer.options.temp) {
            map.removeLayer(layer);
          }
        });
        L.polyline(currentPath, {
          color: penColor,
          weight: 3,
          opacity: 0.7,
          temp: true
        }).addTo(map);
      }
    });
    
    map.on('touchend', function(e) {
      if (!drawingMode || !isDrawing) return;
      if (e && e.originalEvent) { try { e.originalEvent.preventDefault(); } catch(_){} }
      isDrawing = false;
      
      if (currentPath.length > 1) {
        map.eachLayer(function(layer) {
          if (layer.options && layer.options.temp) {
            map.removeLayer(layer);
          }
        });
        var finalLine = L.polyline(currentPath, {
          color: penColor,
          weight: 3,
          opacity: 1
        });
        drawnItems.addLayer(finalLine);
        lastDrawnPath = finalLine; // remember this path
        drawHistory.push(finalLine);
        var undoImg2 = document.getElementById('undo-btn-img');
        if (undoImg2) undoImg2.style.opacity = '1';
        if (selectedUnits.length > 0) {
          const pathLatLngs = lastDrawnPath.getLatLngs();
          startPathMoveForMarkers(selectedUnits.slice(), pathLatLngs, 1500);
        }
      }
      
      currentPath = [];
    });
    

      function computePathMeta(latlngs) {
        const segDist = [];
        let total = 0;
        for (let i = 1; i < latlngs.length; i++) {
          const d = map.distance(latlngs[i-1], latlngs[i]);
          segDist.push(d);
          total += d;
        }
        return { segDist, total };
      }

      function startPathMoveForMarkers(markers, latlngs, speedMetersPerSec) {
        if (!latlngs || latlngs.length < 2 || !markers || markers.length === 0) return;
        // Stop any in-progress move-to animations to avoid conflicts
        unitMoveJobs = [];
        unitsAnimating = false;
        // Stop any existing path animation
        pathMoveJobs = [];
        pathAnimating = false;

        const { segDist, total } = computePathMeta(latlngs);
        if (total <= 0) return;
        const duration = (total / (speedMetersPerSec || 1500)) * 1000;
        const start = performance.now();
        // Create jobs per marker
        markers.forEach(m => {
          pathMoveJobs.push({ marker: m, latlngs, segDist, total, start, duration });
        });
        if (!pathAnimating) requestAnimationFrame(pathAnimLoop);
      }

      function pathAnimLoop() {
        pathAnimating = true;
        const now = performance.now();
        const nextJobs = [];
        for (let i = 0; i < pathMoveJobs.length; i++) {
          const job = pathMoveJobs[i];
          const t = job.duration > 0 ? Math.min(1, (now - job.start) / job.duration) : 1;
          const targetDist = t * job.total;
          const latlngs = job.latlngs;
          const segDist = job.segDist;
          // Find segment
          let acc = 0;
          let si = 0;
          while (si < segDist.length && acc + segDist[si] < targetDist) { acc += segDist[si]; si++; }
          if (si >= segDist.length) {
            job.marker.setLatLng(latlngs[latlngs.length - 1]);
            continue; // job complete
          }
          const segLen = segDist[si];
          const segT = segLen > 0 ? (targetDist - acc) / segLen : 0;
          const a = latlngs[si];
          const b = latlngs[si + 1];
          const lat = a.lat + (b.lat - a.lat) * segT;
          const lng = a.lng + (b.lng - a.lng) * segT;
          job.marker.setLatLng([lat, lng]);
          // Rotate supported unit types
          if (job.marker._icon && ['jetfighter','tank','uav','submarine','battleship','helicopter'].includes(job.marker.unitType)) {
            const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
            const angleDeg = angleRad * 180 / Math.PI;
            job.marker._headingDeg = angleDeg;
            applyMarkerHeading(job.marker);
            updateMarkerTooltip(job.marker);
          }
          if (t < 1) nextJobs.push(job);
        }
        pathMoveJobs = nextJobs;
        if (pathMoveJobs.length > 0) requestAnimationFrame(pathAnimLoop);
        else pathAnimating = false;
      }

    // Button logic
    document.getElementById('draw-btn').onclick = function() { setRadioTool('draw'); };
    
    document.getElementById('clear-btn').onclick = function() {
      clearAllDrawings();
      if (drawingMode) {
        stopFreehandDraw();
        var img = document.getElementById('draw-btn-img');
        img.src = 'image/IconDrawingG.jpg';
        img.alt = 'Freehand Draw';
        document.getElementById('draw-btn').style.backgroundColor = '#95a5a6';
      }
      // Reset undo state
      var undoImg = document.getElementById('undo-btn-img');
      if (undoImg) undoImg.style.opacity = '0.5';
    };

    // Undo last action (drawing path or placed/animated unit)
    document.getElementById('undo-btn').onclick = function() {
      if (!drawHistory || drawHistory.length === 0) return;
      const last = drawHistory.pop();
      if (!last) return;
      // If it's a polyline (drawing)
      if (typeof last.getLatLngs === 'function') {
        try { drawnItems.removeLayer(last); } catch(_) { try { map.removeLayer(last); } catch(_) {} }
        // Update lastDrawnPath to previous polyline if available
        lastDrawnPath = null;
        for (let i = drawHistory.length - 1; i >= 0; i--) {
          const layer = drawHistory[i];
          if (layer && typeof layer.getLatLngs === 'function') { lastDrawnPath = layer; break; }
        }
      } else {
        // Assume it's a marker (placed unit or animated unit)
        try { map.removeLayer(last); } catch(_) {}
        // Remove from allMarkers
        const idx = allMarkers.indexOf(last);
        if (idx !== -1) allMarkers.splice(idx, 1);
        // Remove from selectedUnits if present
        const sidx = selectedUnits.indexOf(last);
        if (sidx !== -1) selectedUnits.splice(sidx, 1);
        // Remove any pending move/animation jobs for this marker
        if (Array.isArray(unitMoveJobs)) {
          unitMoveJobs = unitMoveJobs.filter(j => j && j.marker !== last);
          if (unitMoveJobs.length === 0) { try { unitsAnimating = false; } catch(_){} }
        }
        if (Array.isArray(pathMoveJobs)) {
          pathMoveJobs = pathMoveJobs.filter(j => j && j.marker !== last);
          if (pathMoveJobs.length === 0) { try { pathAnimating = false; } catch(_){} }
        }
      }
      // Dim undo if no more items
      const undoImg = document.getElementById('undo-btn-img');
      if (undoImg) undoImg.style.opacity = drawHistory.length > 0 ? '1' : '0.5';
    };
    
    
    
    // Icon definitions
    var tankIcon = L.icon({
      iconUrl: 'image/IconTankMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var uavIcon = L.icon({
      iconUrl: 'image/IconUAVMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var jetfighterIcon = L.icon({
      iconUrl: 'image/IconJetFighterMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var helicopterIcon = L.icon({
      iconUrl: 'image/IconHelicopterMap.gif',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var submarineIcon = L.icon({
      iconUrl: 'image/IconSubmarineMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });
    var battleshipIcon = L.icon({
      iconUrl: 'image/IconBattleshipMap.png',
      iconSize: [48, 48],
      iconAnchor: [24, 24],
      popupAnchor: [0, -24]
    });

    // Place icon logic
    let placeMode = null;
    let selectedBtn = null;
  // RTS selection + move
  let isSelectMode = false;
  const allMarkers = [];
  const selectedUnits = [];
  let suppressNextMapClick = false;
  let unitMoveJobs = [];
  let unitsAnimating = false;
  // Marquee selection state
  let marqueeActive = false;
  let marqueeMoved = false;
  let marqueeStart = null;
  let marqueeRect = null;
  // Select-mode path gesture disabled (reserved for future)
  let selectPathActive = false;
  let selectPathPoints = [];
  let selectPathTempLine = null;
  // Animate-on-draw mode state
  let animDrawActive = false;
  let animDrawUnitType = null; // 'tank' | 'uav' | 'jetfighter' | 'helicopter' | 'submarine' | 'battleship'
  let animDrawPoints = [];
  let animDrawTempLine = null;
  // Map lock when tools are active
  let lockMapWhenToolActive = false;

  function applyMapLock(lock) {
    if (lock) {
      map.dragging.disable();
      map.touchZoom && map.touchZoom.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();
      map.boxZoom.disable();
      map.keyboard.disable();
      if (map.tap) map.tap.disable();
      if (map && map._container) { try { map._container.style.touchAction = 'none'; } catch(_){} }
    } else {
      map.dragging.enable();
      map.touchZoom && map.touchZoom.enable();
      map.doubleClickZoom.enable();
      map.scrollWheelZoom.enable();
      map.boxZoom.enable();
      map.keyboard.enable();
      if (map.tap) map.tap.enable();
      if (map && map._container) { try { map._container.style.touchAction = ''; } catch(_){} }
    }
  }

    // Attach drag handlers so marker rotates following drag direction
    function applyMarkerHeading(m) {
      if (!m || !m._icon || m._headingDeg == null) return;
      const tStr = m._icon.style.transform || '';
      const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
      m._icon.style.transform = `${cleaned} rotate(${m._headingDeg}deg)`;
  m._icon.style.transformOrigin = '50% 50%';
    }

    function updateMarkerTooltip(m) {
      if (!m) return;
      const heading = ((Math.round((m._headingDeg ?? 0)) % 360) + 360) % 360;
  const content = `<span class="heading-tip">${heading}°</span>`;
      if (m.getTooltip && m.getTooltip()) { m.setTooltipContent(content); }
    }

    function attachDirectionalDrag(m) {
      m.on('dragstart', function() {
        m._lastDragPoint = map.latLngToLayerPoint(m.getLatLng());
      });
      m.on('drag', function() {
        if (!m._icon) return;
        const prev = m._lastDragPoint;
        const curr = map.latLngToLayerPoint(m.getLatLng());
        if (prev && (curr.x !== prev.x || curr.y !== prev.y)) {
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          const angleRad = Math.atan2(-dy, dx); // invert Y for screen coords
          const angleDeg = angleRad * 180 / Math.PI;
          m._headingDeg = angleDeg;
          applyMarkerHeading(m);
          updateMarkerTooltip(m);
          m._lastDragPoint = curr;
        }
      });
      m.on('dragend', function() {
        if (!m._icon) return;
        const prev = m._lastDragPoint;
        const curr = map.latLngToLayerPoint(m.getLatLng());
        if (prev && (curr.x !== prev.x || curr.y !== prev.y)) {
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          const angleRad = Math.atan2(-dy, dx);
          const angleDeg = angleRad * 180 / Math.PI;
          m._headingDeg = angleDeg;
          applyMarkerHeading(m);
          updateMarkerTooltip(m);
        }
        m._lastDragPoint = null;
      });
    }

    function setPlaceMode(mode) {
      // Deselect previous button
      if (selectedBtn) {
        if (selectedBtn.id === 'tank-btn') selectedBtn.querySelector('img').src = 'image/IconTankG.jpg';
        if (selectedBtn.id === 'uav-btn') selectedBtn.querySelector('img').src = 'image/IconUAVG.jpg';
        if (selectedBtn.id === 'jetfighter-btn') selectedBtn.querySelector('img').src = 'image/IconJetFighterG.jpg';
        if (selectedBtn.id === 'helicopter-btn') selectedBtn.querySelector('img').src = 'image/IconHelicopterG.jpg';
        if (selectedBtn.id === 'submarine-btn') selectedBtn.querySelector('img').src = 'image/IconSubmarineG.jpg';
        if (selectedBtn.id === 'battleship-btn') selectedBtn.querySelector('img').src = 'image/IconBattleshipG.jpg';
        selectedBtn.classList.remove('selected');
      }
      // Select new button
      placeMode = mode;
      // Turning on place mode cancels select mode
      if (isSelectMode) {
        isSelectMode = false;
        const selBtn = document.getElementById('select-mode-btn');
        if (selBtn) selBtn.classList.remove('selected');
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
      }
      // Toggle off measuring if active
      if (typeof measuring !== 'undefined' && measuring) {
        try { stopMeasuring(); } catch(_) {}
        const mImg = document.getElementById('measure-btn-img');
        if (mImg) mImg.src = 'image/IconRulerG.jpg';
        const mBtn = document.getElementById('measure-btn');
        if (mBtn) mBtn.style.backgroundColor = '#95a5a6';
      }
      try { updateMapLockByTools(); } catch(_) {}
    map.getContainer().style.cursor = 'crosshair';
  // Deactivate Move when a tool becomes active
  if (typeof deactivateMove === 'function') deactivateMove();
  // movement policy handled centrally by updateMapLockByTools()
      if (mode === 'tank') {
        selectedBtn = document.getElementById('tank-btn');
        selectedBtn.querySelector('img').src = 'image/IconTankL.jpg';
      } else if (mode === 'uav') {
        selectedBtn = document.getElementById('uav-btn');
        selectedBtn.querySelector('img').src = 'image/IconUAVL.jpg';
      } else if (mode === 'jetfighter') {
        selectedBtn = document.getElementById('jetfighter-btn');
        selectedBtn.querySelector('img').src = 'image/IconJetFighterL.jpg';
      } else if (mode === 'helicopter') {
        selectedBtn = document.getElementById('helicopter-btn');
        selectedBtn.querySelector('img').src = 'image/IconHelicopterL.jpg';
      } else if (mode === 'submarine') {
        selectedBtn = document.getElementById('submarine-btn');
        selectedBtn.querySelector('img').src = 'image/IconSubmarineL.jpg';
      } else if (mode === 'battleship') {
        selectedBtn = document.getElementById('battleship-btn');
        selectedBtn.querySelector('img').src = 'image/IconBattleshipL.jpg';
      }
      selectedBtn.classList.add('selected');
    }

    function clearPlaceMode() {
      if (selectedBtn) {
        if (selectedBtn.id === 'tank-btn') selectedBtn.querySelector('img').src = 'image/IconTankG.jpg';
        if (selectedBtn.id === 'uav-btn') selectedBtn.querySelector('img').src = 'image/IconUAVG.jpg';
        if (selectedBtn.id === 'jetfighter-btn') selectedBtn.querySelector('img').src = 'image/IconJetFighterG.jpg';
        if (selectedBtn.id === 'helicopter-btn') selectedBtn.querySelector('img').src = 'image/IconHelicopterG.jpg';
        if (selectedBtn.id === 'submarine-btn') selectedBtn.querySelector('img').src = 'image/IconSubmarineG.jpg';
        if (selectedBtn.id === 'battleship-btn') selectedBtn.querySelector('img').src = 'image/IconBattleshipG.jpg';
        selectedBtn.classList.remove('selected');
        selectedBtn = null;
      }
      placeMode = null;
      map.getContainer().style.cursor = '';
  // movement policy handled centrally by updateMapLockByTools()
      try { updateMapLockByTools(); } catch(_) {}
    }

    // Animate-on-draw mode: toggle per unit button
    function updateUnitButtonsVisual(activeType) {
      const mapImg = {
        tank: ['image/IconTankG.jpg','image/IconTankL.jpg'],
        uav: ['image/IconUAVG.jpg','image/IconUAVL.jpg'],
        jetfighter: ['image/IconJetFighterG.jpg','image/IconJetFighterL.jpg'],
        helicopter: ['image/IconHelicopterG.jpg','image/IconHelicopterL.jpg'],
        submarine: ['image/IconSubmarineG.jpg','image/IconSubmarineL.jpg'],
        battleship: ['image/IconBattleshipG.jpg','image/IconBattleshipL.jpg']
      };
      const ids = ['tank','uav','jetfighter','helicopter','submarine','battleship'];
      ids.forEach(id => {
        const btn = document.getElementById(id+'-btn');
        if (!btn) return;
        const img = btn.querySelector('img');
        if (!img) return;
        img.src = id === activeType ? mapImg[id][1] : mapImg[id][0];
      });
    }

    function setAnimDrawMode(type) {
      // Exit conflicting modes
      if (isSelectMode) {
        isSelectMode = false;
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
      }
      if (measuring) {
        stopMeasuring();
        const img = document.getElementById('measure-btn-img');
        if (img) img.src = 'image/IconRulerG.jpg';
        const btn = document.getElementById('measure-btn');
        if (btn) btn.style.backgroundColor = '#95a5a6';
      }
      if (drawingMode) {
        stopFreehandDraw();
        const drawImg = document.getElementById('draw-btn-img');
        if (drawImg) drawImg.src = 'image/IconDrawingG.jpg';
        const drawBtn = document.getElementById('draw-btn');
        if (drawBtn) drawBtn.style.backgroundColor = '#95a5a6';
        const palettePanel = document.getElementById('color-palette-panel');
        if (palettePanel) palettePanel.style.display = 'none';
      }
      // Clear placement mode if any
      clearPlaceMode();
      animDrawActive = true;
      animDrawUnitType = type;
      updateUnitButtonsVisual(type);
      map.getContainer().style.cursor = 'crosshair';
  // movement policy handled centrally by updateMapLockByTools()
      try { updateMapLockByTools(); } catch(_) {}
    }

    function clearAnimDrawMode() {
      animDrawActive = false;
      animDrawUnitType = null;
      updateUnitButtonsVisual(null);
      map.getContainer().style.cursor = '';
  // movement policy handled centrally by updateMapLockByTools()
      try { updateMapLockByTools(); } catch(_) {}
    }

    document.getElementById('tank-btn').onclick = function() { setRadioTool('anim:tank'); };
    document.getElementById('uav-btn').onclick = function() { setRadioTool('anim:uav'); };
    document.getElementById('jetfighter-btn').onclick = function() { setRadioTool('anim:jetfighter'); };
    document.getElementById('helicopter-btn').onclick = function() { setRadioTool('anim:helicopter'); };
    document.getElementById('submarine-btn').onclick = function() { setRadioTool('anim:submarine'); };
    document.getElementById('battleship-btn').onclick = function() { setRadioTool('anim:battleship'); };

    // Lock toggle button logic
    const lockBtn = document.getElementById('lock-map-btn');
    if (lockBtn) {
      lockBtn.addEventListener('click', function() {
        lockMapWhenToolActive = !lockMapWhenToolActive;
        this.textContent = lockMapWhenToolActive ? '🔒' : '🔓';
        // Do not override movement policy; just update icon then re-apply central rule
        try { updateMapLockByTools(); } catch(_) {}
      });
    }

    map.on('click', function(e) {
      if (animDrawActive) return; // block placement while anim-draw mode is active
      if (!placeMode) return;
      let icon;
      if (placeMode === 'tank') icon = tankIcon;
      if (placeMode === 'uav') icon = uavIcon;
      if (placeMode === 'jetfighter') icon = jetfighterIcon;
      if (placeMode === 'helicopter') icon = helicopterIcon;
      if (placeMode === 'submarine') icon = submarineIcon;
  if (placeMode === 'battleship') icon = battleshipIcon;
      if (icon) {
  const m = L.marker(e.latlng, {icon: icon, draggable: true}).addTo(map);
        m.unitType = placeMode;
        m.isSelected = false;
  m._headingDeg = 0;
  m.bindTooltip('<span class="heading-tip">0°</span>', {permanent: false, direction: 'top', sticky: true, opacity: 0.9, offset: [0, -12], className: 'heading-tooltip'});
  allMarkers.push(m);
  // Add unit placement to undo history
  drawHistory.push(m);
  const undoImgP = document.getElementById('undo-btn-img');
  if (undoImgP) undoImgP.style.opacity = '1';
        // Click to toggle selection when in select mode
        m.on('click', function(ev) {
          if (!isSelectMode) return;
          if (ev && ev.originalEvent && L && L.DomEvent) { try { L.DomEvent.stopPropagation(ev); } catch(_){} }
          toggleUnitSelection(m);
          // Do not suppress; next explicit map click becomes the destination
          suppressNextMapClick = false;
        });
        // Directional drag for applicable unit types
        if (m.unitType === 'jetfighter' || m.unitType === 'tank' || m.unitType === 'uav' || m.unitType === 'submarine' || m.unitType === 'battleship' || m.unitType === 'helicopter') {
          attachDirectionalDrag(m);
        }
        // Do NOT clear placeMode here, so user can keep spawning icons
      }
    });

    // Keep icon heading consistent across pan/zoom
    map.on('zoomend moveend', function() {
      allMarkers.forEach(m => applyMarkerHeading(m));
    });

    function toggleUnitSelection(marker) {
      marker.isSelected = !marker.isSelected;
      if (marker._icon) {
        if (marker.isSelected) marker._icon.classList.add('unit-selected');
        else marker._icon.classList.remove('unit-selected');
      }
      const idx = selectedUnits.indexOf(marker);
      if (marker.isSelected && idx === -1) selectedUnits.push(marker);
      if (!marker.isSelected && idx !== -1) selectedUnits.splice(idx, 1);
    }

    // Select mode toggle
    document.getElementById('select-mode-btn').onclick = function() { setRadioTool('select'); };

    // Issue move command on map click in select mode (when not clicking a marker)
    map.on('click', function(e) {
      if (!isSelectMode) return;
      if (suppressNextMapClick) { suppressNextMapClick = false; return; }
      if (selectedUnits.length === 0) return;
      moveSelectedUnitsTo(e.latlng);
    });

    // Select-mode marquee selection (separate mouse and touch)
    map.on('mousedown', function(e) {
      if (!isSelectMode) return;
      if (e.originalEvent && e.originalEvent.button !== 0) return; // left button only
      marqueeActive = true;
      marqueeMoved = false;
      marqueeStart = e.latlng;
      map.dragging.disable();
      marqueeRect = L.rectangle([marqueeStart, marqueeStart], {
        color: '#00aaff',
        weight: 2,
        dashArray: '6,4',
        fillColor: '#00aaff',
        fillOpacity: 0.1,
        interactive: false
      }).addTo(map);
    });

    map.on('mousemove', function(e) {
      if (!isSelectMode) return;
      if (!marqueeActive || !marqueeRect) return;
      const p0 = map.latLngToContainerPoint(marqueeStart);
      const p1 = map.latLngToContainerPoint(e.latlng);
      const dx = Math.abs(p1.x - p0.x);
      const dy = Math.abs(p1.y - p0.y);
      if (dx + dy > 5) marqueeMoved = true; // threshold to count as drag
      const bounds = L.latLngBounds(marqueeStart, e.latlng);
      marqueeRect.setBounds(bounds);
    });

    map.on('mouseup', function(e) {
      if (!isSelectMode) return;
      if (!marqueeActive) return;
      map.dragging.enable();
      if (marqueeMoved && marqueeRect) {
        const bounds = marqueeRect.getBounds();
        while (selectedUnits.length) {
          const m = selectedUnits.pop();
          m.isSelected = false;
          if (m._icon) m._icon.classList.remove('unit-selected');
        }
        allMarkers.forEach(m => {
          if (bounds.contains(m.getLatLng())) {
            m.isSelected = true;
            if (m._icon) m._icon.classList.add('unit-selected');
            selectedUnits.push(m);
          }
        });
        suppressNextMapClick = true;
      }
      if (marqueeRect) { map.removeLayer(marqueeRect); marqueeRect = null; }
      marqueeActive = false;
      marqueeMoved = false;
      marqueeStart = null;
    });

    // Touch equivalents for select-mode marquee
    map.on('touchstart', function(e) {
      if (!isSelectMode) return;
      if (!e.originalEvent) return;
      const touch = e.originalEvent.touches && e.originalEvent.touches[0] ? e.originalEvent.touches[0] : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      e.originalEvent.preventDefault();
      marqueeActive = true;
      marqueeMoved = false;
      marqueeStart = latlng;
      map.dragging.disable();
      marqueeRect = L.rectangle([marqueeStart, marqueeStart], {
        color: '#00aaff',
        weight: 2,
        dashArray: '6,4',
        fillColor: '#00aaff',
        fillOpacity: 0.1,
        interactive: false
      }).addTo(map);
    });

    map.on('touchmove', function(e) {
      if (!isSelectMode) return;
      if (!e.originalEvent) return;
      const touch = e.originalEvent.touches && e.originalEvent.touches[0] ? e.originalEvent.touches[0] : (e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0] : null);
      if (!touch) return;
      const rect = map.getContainer().getBoundingClientRect();
      const latlng = map.containerPointToLatLng([touch.clientX - rect.left, touch.clientY - rect.top]);
      if (marqueeActive && marqueeRect) {
        e.originalEvent.preventDefault();
        const p0 = map.latLngToContainerPoint(marqueeStart);
        const p1 = map.latLngToContainerPoint(latlng);
        const dx = Math.abs(p1.x - p0.x);
        const dy = Math.abs(p1.y - p0.y);
        if (dx + dy > 5) marqueeMoved = true;
        const bounds = L.latLngBounds(marqueeStart, latlng);
        marqueeRect.setBounds(bounds);
      }
    });

    map.on('touchend', function(e) {
      if (!isSelectMode) return;
      if (marqueeActive) {
        map.dragging.enable();
        if (marqueeMoved && marqueeRect) {
          const bounds = marqueeRect.getBounds();
          while (selectedUnits.length) {
            const m = selectedUnits.pop();
            m.isSelected = false;
            if (m._icon) m._icon.classList.remove('unit-selected');
          }
          allMarkers.forEach(m => {
            if (bounds.contains(m.getLatLng())) {
              m.isSelected = true;
              if (m._icon) m._icon.classList.add('unit-selected');
              selectedUnits.push(m);
            }
          });
          suppressNextMapClick = true;
        }
        if (marqueeRect) { map.removeLayer(marqueeRect); marqueeRect = null; }
        marqueeActive = false;
        marqueeMoved = false;
        marqueeStart = null;
      }
    });

    // Geodesic destination from center by distance (m) and bearing (deg)
    function destinationPoint(center, distance, bearingDeg) {
      const R = 6371000; // meters
      const br = bearingDeg * Math.PI / 180;
      const lat1 = center.lat * Math.PI / 180;
      const lon1 = center.lng * Math.PI / 180;
      const dr = distance / R;
      const sinLat1 = Math.sin(lat1), cosLat1 = Math.cos(lat1);
      const sinDr = Math.sin(dr), cosDr = Math.cos(dr);
      const sinLat2 = sinLat1 * cosDr + cosLat1 * sinDr * Math.cos(br);
      const lat2 = Math.asin(sinLat2);
      const y = Math.sin(br) * sinDr * cosLat1;
      const x = cosDr - sinLat1 * sinLat2;
      const lon2 = lon1 + Math.atan2(y, x);
      return L.latLng(lat2 * 180 / Math.PI, ((lon2 * 180 / Math.PI + 540) % 360) - 180);
    }

    function moveSelectedUnitsTo(destLatLng) {
      const DURATION_MS = 3000; // complete move within 3 seconds
      unitMoveJobs = [];
      const now = performance.now();

      const n = selectedUnits.length;
      const targets = [];
      if (n === 1) {
        targets.push(destLatLng);
      } else {
        const baseSpacing = 120; // meters between rings
        let remaining = n;
        let ring = 1;
        while (remaining > 0) {
          const capacity = 6 * ring; // 6, 12, 18, ...
          const onRing = Math.min(remaining, capacity);
          for (let j = 0; j < onRing; j++) {
            const angle = (360 / onRing) * j; // degrees
            targets.push(destinationPoint(destLatLng, baseSpacing * ring, angle));
          }
          remaining -= onRing;
          ring++;
        }
      }

      // Assign targets in order of selection
      selectedUnits.forEach((m, i) => {
        const target = targets[Math.min(i, targets.length - 1)];
        const from = m.getLatLng();
        const dist = map.distance(from, target);
        const duration = DURATION_MS; // constant duration for all
        unitMoveJobs.push({ marker: m, from, to: target, dist, start: now, duration });
      });
      if (!unitsAnimating) {
        unitsAnimLoop();
      }
    }

    function unitsAnimLoop() {
      unitsAnimating = true;
      const now = performance.now();
      let remaining = 0;
      unitMoveJobs.forEach(job => {
        const t = job.duration > 0 ? Math.min(1, (now - job.start) / job.duration) : 1;
        const lat = job.from.lat + (job.to.lat - job.from.lat) * t;
        const lng = job.from.lng + (job.to.lng - job.from.lng) * t;
        const a = job.from; const b = job.to;
        job.marker.setLatLng([lat, lng]);
  if (job.marker._icon && ['jetfighter','tank','uav','submarine','battleship','helicopter'].includes(job.marker.unitType)) {
          const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
          const angleDeg = angleRad * 180 / Math.PI;
          job.marker._headingDeg = angleDeg;
          applyMarkerHeading(job.marker);
          updateMarkerTooltip(job.marker);
        }
        if (t < 1) remaining++;
      });
      if (remaining > 0) {
        requestAnimationFrame(unitsAnimLoop);
      } else {
        unitsAnimating = false;
      }
    }

    

    

    // Animate-on-draw gesture (mouse)
    map.on('mousedown', function(e) {
      if (!animDrawActive || !animDrawUnitType) return;
      if (e && e.originalEvent) { e.originalEvent.preventDefault(); }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      animDrawPoints = [e.latlng];
      // Lock interactions during the draw gesture
      map.dragging.disable();
      map.touchZoom && map.touchZoom.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();
      map.boxZoom.disable();
      map.keyboard.disable();
      if (map.tap) map.tap.disable();
  if (animDrawTempLine) { map.removeLayer(animDrawTempLine); animDrawTempLine = null; }
  animDrawTempLine = L.polyline(animDrawPoints, { color: '#ffffff', weight: 3, opacity: 0.1, temp: true }).addTo(map);
    });

    map.on('mousemove', function(e) {
      if (!animDrawActive || animDrawPoints.length === 0) return;
      if (e && e.originalEvent) { e.originalEvent.preventDefault(); }
      if (typeof L !== 'undefined' && L.DomEvent) { try { L.DomEvent.stop(e.originalEvent); } catch(_){} }
      animDrawPoints.push(e.latlng);
      if (animDrawTempLine) animDrawTempLine.setLatLngs(animDrawPoints);
    });

    map.on('mouseup', function(e) {
      if (!animDrawActive || animDrawPoints.length === 0) return;
  // Re-enable interactions
  map.dragging.enable();
  map.touchZoom && map.touchZoom.enable();
  map.doubleClickZoom.enable();
  map.scrollWheelZoom.enable();
  map.boxZoom.enable();
  map.keyboard.enable();
  if (map.tap) map.tap.enable();
      // Remove the drawn path immediately (disappear)
      if (animDrawTempLine) { map.removeLayer(animDrawTempLine); animDrawTempLine = null; }
      const pts = animDrawPoints.slice();
      animDrawPoints = [];
      if (pts.length < 2) return;
      // Create a temporary marker for the chosen unit
      let icon = null;
      if (animDrawUnitType === 'tank') icon = tankIcon;
      if (animDrawUnitType === 'uav') icon = uavIcon;
      if (animDrawUnitType === 'jetfighter') icon = jetfighterIcon;
      if (animDrawUnitType === 'helicopter') icon = helicopterIcon;
      if (animDrawUnitType === 'submarine') icon = submarineIcon;
      if (animDrawUnitType === 'battleship') icon = battleshipIcon;
      if (!icon) return;
      const animMarker = L.marker(pts[0], { icon: icon, draggable: true }).addTo(map);
      animMarker.unitType = animDrawUnitType;
      animMarker.isSelected = false;
      animMarker._headingDeg = 0;
      animMarker.bindTooltip('<span class="heading-tip">0°</span>', {permanent: false, direction: 'top', sticky: true, opacity: 0.9, offset: [0, -12], className: 'heading-tooltip'});
      // Enable selection by click in select mode
      animMarker.on('click', function(ev) {
        if (!isSelectMode) return;
        if (ev && ev.originalEvent && L && L.DomEvent) { try { L.DomEvent.stopPropagation(ev); } catch(_){} }
        toggleUnitSelection(animMarker);
        suppressNextMapClick = false;
      });
      // Drag rotation for supported units
      attachDirectionalDrag(animMarker);
  allMarkers.push(animMarker);
  // Allow undo of the animated unit creation
  drawHistory.push(animMarker);
  const undoImgAnim = document.getElementById('undo-btn-img');
  if (undoImgAnim) undoImgAnim.style.opacity = '1';
      // (removed duplicate bind/click/drag/push)
      const segDist = [];
      let total = 0;
      for (let i = 1; i < pts.length; i++) {
        const d = map.distance(pts[i-1], pts[i]);
        segDist.push(d);
        total += d;
      }
      const duration = 5000;
      const startTime = performance.now();
      function step(now) {
        let t = (now - startTime) / duration;
        if (t < 0) t = 0; if (t > 1) t = 1;
        const targetDist = total * t;
        let acc = 0;
        let si = 0;
        while (si < segDist.length && acc + segDist[si] < targetDist) { acc += segDist[si]; si++; }
        if (si >= segDist.length) { animMarker.setLatLng(pts[pts.length - 1]); return; }
        const a = pts[si];
        const b = pts[si + 1];
        const segLen = segDist[si];
        const segT = segLen > 0 ? (targetDist - acc) / segLen : 0;
        const lat = a.lat + (b.lat - a.lat) * segT;
        const lng = a.lng + (b.lng - a.lng) * segT;
        animMarker.setLatLng([lat, lng]);
        const angleRad = Math.atan2(b.lng - a.lng, b.lat - a.lat);
        const angleDeg = angleRad * 180 / Math.PI;
        animMarker._headingDeg = angleDeg;
        const tStr = animMarker._icon && animMarker._icon.style.transform || '';
        const cleaned = tStr.replace(/rotate\([^)]*\)/, '').trim();
        if (animMarker._icon) {
          animMarker._icon.style.transform = `${cleaned} rotate(${angleDeg}deg)`;
          animMarker._icon.style.transformOrigin = '16px 16px';
        }
        if (t < 1) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    });

    // Memorize and go to location logic
    // Load memorized locations from localStorage
    function loadMemorized() {
      try {
        const saved = localStorage.getItem('memorizedLocations');
        if (saved) {
          const arr = JSON.parse(saved);
          // Convert center back to LatLng objects
          return arr.map(loc => {
            if (!loc) return null;
            return {
              ...loc,
              center: L.latLng(loc.center.lat, loc.center.lng)
            };
          });
        }
      } catch (e) {}
      return [null, null, null, null, null];
    }

    function saveMemorized() {
      localStorage.setItem('memorizedLocations', JSON.stringify(memorized));
    }

    var memorized = loadMemorized();
    var currentMode = 'memorize'; // Default to memorize mode
    
    // Function to get elevation from coordinates
    async function getElevation(lat, lng) {
      try {
        // Using Open-Elevation API (free service)
        const response = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lng}`);
        const data = await response.json();
        if (data.results && data.results.length > 0) {
          return data.results[0].elevation;
        }
        return null;
      } catch (error) {
        console.log('Elevation service unavailable, using map zoom as approximation');
        // Fallback: approximate elevation based on zoom level (very rough estimate)
        const zoom = map.getZoom();
        return Math.max(0, (20 - zoom) * 100); // Rough approximation
      }
    }
    
    async function memorize(idx) {
      const center = map.getCenter();
      const zoom = map.getZoom();
      
      // Show loading message
      const loadingMsg = document.createElement('div');
      loadingMsg.textContent = 'Getting elevation data...';
      loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:10px;border-radius:5px;z-index:9999;';
      document.body.appendChild(loadingMsg);
      
      try {
        const elevation = await getElevation(center.lat, center.lng);
        memorized[idx] = {
          center: center,
          zoom: zoom,
          elevation: elevation,
          timestamp: new Date().toLocaleString()
        };
        saveMemorized();
  document.body.removeChild(loadingMsg);
  updateLocationButtons(); // Update button appearance
  showToast(`Saved Location ${idx+1}`);
      } catch (error) {
        document.body.removeChild(loadingMsg);
        alert('Error getting elevation data. Location saved without elevation.');
        memorized[idx] = {
          center: center,
          zoom: zoom,
          elevation: null,
          timestamp: new Date().toLocaleString()
        };
        saveMemorized();
        updateLocationButtons();
      }
    }
    
    function goTo(idx) {
      if (!memorized[idx]) {
        alert('No location memorized for '+(idx+1));
        return;
      }
  const target = memorized[idx];
  const elevationText = target.elevation !== null ? `${Math.round(target.elevation)}m` : 'Unknown';

      // Preload tiles for smoother fly-in
      preloadTiles(target.center, target.zoom).then(() => {
        map.setView(target.center, target.zoom, {animate: true, duration: 2});
      });
    }

    // Preload tiles for a given center and zoom
    function preloadTiles(center, zoom) {
      return new Promise(resolve => {
        // Calculate tile coordinates for the center
        var tileSize = 256;
        var crs = map.options.crs;
        var tileCoords = crs.project(center);
        var scale = crs.scale(zoom);
        var tileX = Math.floor(tileCoords.x * scale / tileSize);
        var tileY = Math.floor(tileCoords.y * scale / tileSize);

        // Preload a 3x3 grid of tiles around the center
        var promises = [];
        for (var dx = -1; dx <= 1; dx++) {
          for (var dy = -1; dy <= 1; dy++) {
            var x = tileX + dx;
            var y = tileY + dy;
            var url = map._layers[Object.keys(map._layers)[0]]._url
              .replace('{z}', zoom)
              .replace('{x}', x)
              .replace('{y}', y);
            promises.push(fetch(url).catch(()=>{}));
          }
        }
        Promise.all(promises).then(() => setTimeout(resolve, 200)); // Wait a bit for browser cache
      });
    }
    
    function showAllLocations() {
      let locationList = 'Memorized Locations:\n\n';
      let hasLocations = false;
      
      for (let i = 0; i < 5; i++) {
        if (memorized[i]) {
          hasLocations = true;
          const loc = memorized[i];
          const elevationText = loc.elevation !== null ? `${Math.round(loc.elevation)}m` : 'Unknown';
          locationList += `Map ${i+1}:\n`;
          locationList += `  Coordinates: ${loc.center.lat.toFixed(6)}, ${loc.center.lng.toFixed(6)}\n`;
          locationList += `  Elevation: ${elevationText}\n`;
          locationList += `  Zoom Level: ${loc.zoom}\n`;
          locationList += `  Saved: ${loc.timestamp}\n\n`;
        }
      }
      
      if (!hasLocations) {
        alert('No locations have been memorized yet.');
      } else {
        alert(locationList);
      }
    }
    
    function updateLocationButtons() {
      for (let i = 1; i <= 5; i++) {
        const btn = document.getElementById('location-' + i);
        const img = document.getElementById('location-img-' + i);
        const isMemorized = memorized[i-1] !== null;
        if (currentMode === 'memorize') {
          img.src = 'image/IconMapR.jpg';
        } else {
          img.src = isMemorized ? 'image/IconMapL.jpg' : 'image/IconMapG.jpg';
        }
        btn.className = 'location-btn';
        btn.style.opacity = currentMode === 'go' && !isMemorized ? '0.5' : '1';
      }
      saveMemorized(); // Save state on every update
    }
    
    function handleLocationClick(index) {
      if (currentMode === 'memorize') {
        memorize(index);
      } else {
        goTo(index);
      }
    }
    
    // Set up location button event listeners
    for (let i = 1; i <= 5; i++) {
      document.getElementById('location-' + i).onclick = function() {
        handleLocationClick(i - 1);
      };
    }
    
    // Mode switch icon logic
    function setMode(mode) {
      currentMode = mode;
      updateLocationButtons();
      // Update icons
      if (mode === 'memorize') {
        document.getElementById('mode-memorize').classList.add('selected');
        document.getElementById('mode-go').classList.remove('selected');
        document.getElementById('mode-memorize-img').src = 'image/IconSaveL.jpg';
        document.getElementById('mode-go-img').src = 'image/IconGotoMapG.jpg';
      } else {
        document.getElementById('mode-go').classList.add('selected');
        document.getElementById('mode-memorize').classList.remove('selected');
        document.getElementById('mode-memorize-img').src = 'image/IconSaveG.jpg';
        document.getElementById('mode-go-img').src = 'image/IconGotoMapL.jpg';
      }
    }

    document.getElementById('mode-memorize').onclick = function() { setMode('memorize'); };
    document.getElementById('mode-go').onclick = function() { setMode('go'); };

    // Measuring tool variables
    var measuring = false;
    var measurePoints = [];
    var measureLine = null;
    var measureMarkers = [];
    var measureTooltip = null;

    function startMeasuring() {
      measuring = true;
      measurePoints = [];
      if (measureLine) { map.removeLayer(measureLine); measureLine = null; }
      measureMarkers.forEach(m => map.removeLayer(m));
      measureMarkers = [];
      if (measureTooltip) { map.removeLayer(measureTooltip); measureTooltip = null; }
      map.getContainer().style.cursor = 'crosshair';
  // Do not disable other tools; allow switching like radio buttons
      // Exit select mode
      if (typeof isSelectMode !== 'undefined' && isSelectMode) {
        isSelectMode = false;
        const selBtn = document.getElementById('select-mode-btn');
        if (selBtn) selBtn.classList.remove('selected');
        const selImg = document.getElementById('select-mode-btn-img');
        if (selImg) selImg.src = 'image/IconSelectRectangleG.jpg';
      }
      // Exit placement
      clearPlaceMode();
      // Exit animate-on-draw
      if (typeof animDrawActive !== 'undefined' && animDrawActive) {
        clearAnimDrawMode();
        if (typeof animDrawTempLine !== 'undefined' && animDrawTempLine) { try { map.removeLayer(animDrawTempLine); } catch(_){} animDrawTempLine = null; }
        if (typeof animDrawPoints !== 'undefined') animDrawPoints = [];
      }
      // Exit freehand drawing
      if (typeof drawingMode !== 'undefined' && drawingMode) {
        stopFreehandDraw();
        const drawImg = document.getElementById('draw-btn-img');
        if (drawImg) drawImg.src = 'image/IconDrawingG.jpg';
        const drawBtn = document.getElementById('draw-btn');
        if (drawBtn) drawBtn.style.backgroundColor = '#95a5a6';
        const palettePanel = document.getElementById('color-palette-panel');
        if (palettePanel) palettePanel.style.display = 'none';
      }
    // Lock map interactions while measuring
    map.dragging.disable();
    if (map.touchZoom) map.touchZoom.disable();
    map.doubleClickZoom.disable();
    map.scrollWheelZoom.disable();
    map.boxZoom.disable();
    map.keyboard.disable();
    if (map.tap) map.tap.disable();
    }

    function stopMeasuring() {
      measuring = false;
      map.getContainer().style.cursor = '';
  // Keep other tools enabled (radio behavior)
  // Restore interactions
  map.dragging.enable();
  if (map.touchZoom) map.touchZoom.enable();
  map.doubleClickZoom.enable();
  map.scrollWheelZoom.enable();
  map.boxZoom.enable();
  map.keyboard.enable();
  if (map.tap) map.tap.enable();
    }

    // Measuring no longer disables other tool buttons; it behaves like radio with other tools

    function updateMeasure() {
      if (measureLine) { map.removeLayer(measureLine); measureLine = null; }
      measureMarkers.forEach(m => map.removeLayer(m));
      measureMarkers = [];
      if (measurePoints.length > 1) {
        measureLine = L.polyline(measurePoints, {color: '#ffffff', weight: 2, dashArray: '6,6', opacity: 0.9}).addTo(map);
      }
      measurePoints.forEach((pt, i) => {
        var marker = L.circleMarker(pt, {radius: 4, color: '#ffffff', fillColor: '#000000', fillOpacity: 0.8, weight: 1}).addTo(map);
        measureMarkers.push(marker);
      });
      // Tooltip for total distance
      if (measureTooltip) { map.removeLayer(measureTooltip); measureTooltip = null; }
      if (measurePoints.length > 1) {
        var dist = 0;
        for (var i=1; i<measurePoints.length; i++) {
          dist += map.distance(measurePoints[i-1], measurePoints[i]);
        }
        var last = measurePoints[measurePoints.length-1];
        var distText = dist >= 1000 ? (dist/1000).toFixed(2) + ' km' : dist.toFixed(1) + ' m';
        measureTooltip = L.popup({closeButton:false, autoClose:false, className:'measure-popup'})
          .setLatLng(last)
          .setContent('<b>' + distText + '</b>')
          .addTo(map);
      }
    }

    document.getElementById('measure-btn').onclick = function() { setRadioTool('measure'); };

    map.on('click', function(e) {
      if (measuring) {
        measurePoints.push(e.latlng);
        updateMeasure();
      }
    });

    map.on('dblclick', function(e) {
      if (measuring) {
        stopMeasuring();
        document.getElementById('measure-btn').textContent = 'Measure Distance';
        document.getElementById('measure-btn').style.backgroundColor = '#95a5a6';
        // Do NOT clear measurement visuals here
      }
    });

    // Initialize button appearance
    updateLocationButtons();

    // Palette visibility is handled inside draw start/stop and button handler

    // Pen color selection logic
    var penColor = "#ff0000"; // Default to red
    document.querySelectorAll('.palette-color-btn').forEach(function(btn) {
      btn.onclick = function() {
        penColor = btn.getAttribute('data-color');
        document.querySelectorAll('.palette-color-btn').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid #333';
      };
    });

    // penColor is applied in mouse/touch drawing handlers above
  </script>
</body>
</html>
